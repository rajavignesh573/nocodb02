"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateFormulaAndExtractTreeWithType = validateFormulaAndExtractTreeWithType;
const jsep_1 = __importDefault(require("jsep"));
const UITypes_1 = __importDefault(require("../UITypes"));
const enums_1 = require("./enums");
const error_1 = require("./error");
const sqlUi_1 = require("../sqlUi");
const handle_formula_error_1 = require("./handle-formula-error");
const formulas_1 = require("./formulas");
const hooks_1 = require("./hooks");
async function extractColumnIdentifierType({ col, columns, getMeta, clientOrSqlUi, }) {
    const res = {};
    const sqlUI = typeof clientOrSqlUi === 'string'
        ? sqlUi_1.SqlUiFactory.create({ client: clientOrSqlUi })
        : clientOrSqlUi;
    switch (col === null || col === void 0 ? void 0 : col.uidt) {
        // string
        case UITypes_1.default.SingleLineText:
        case UITypes_1.default.LongText:
        case UITypes_1.default.MultiSelect:
        case UITypes_1.default.SingleSelect:
        case UITypes_1.default.PhoneNumber:
        case UITypes_1.default.Email:
        case UITypes_1.default.URL:
        case UITypes_1.default.User:
        case UITypes_1.default.CreatedBy:
        case UITypes_1.default.LastModifiedBy:
            res.dataType = enums_1.FormulaDataTypes.STRING;
            break;
        // numeric
        case UITypes_1.default.Year:
        case UITypes_1.default.Number:
        case UITypes_1.default.Decimal:
        case UITypes_1.default.Rating:
        case UITypes_1.default.Count:
        case UITypes_1.default.AutoNumber:
            res.dataType = enums_1.FormulaDataTypes.NUMERIC;
            break;
        // date
        case UITypes_1.default.Date:
        case UITypes_1.default.DateTime:
        case UITypes_1.default.CreatedTime:
        case UITypes_1.default.LastModifiedTime:
            res.dataType = enums_1.FormulaDataTypes.DATE;
            break;
        case UITypes_1.default.Currency:
        case UITypes_1.default.Percent:
        case UITypes_1.default.Duration:
        case UITypes_1.default.Links:
            res.dataType = enums_1.FormulaDataTypes.NUMERIC;
            break;
        case UITypes_1.default.Rollup:
            {
                const rollupFunction = col.colOptions.rollup_function;
                if ([
                    'count',
                    'avg',
                    'sum',
                    'countDistinct',
                    'sumDistinct',
                    'avgDistinct',
                ].includes(rollupFunction)) {
                    // these functions produce a numeric value, which can be used in numeric functions
                    res.dataType = enums_1.FormulaDataTypes.NUMERIC;
                }
                else {
                    const relationColumnOpt = columns.find((column) => column.id === col.colOptions.fk_relation_column_id);
                    // the value is based on the foreign rollup column type
                    const refTableMeta = await getMeta(relationColumnOpt.colOptions
                        .fk_related_model_id);
                    const refTableColumns = refTableMeta.columns;
                    const childFieldColumn = refTableColumns.find((column) => column.id === col.colOptions.fk_rollup_column_id);
                    // extract type and add to res
                    Object.assign(res, await extractColumnIdentifierType({
                        col: childFieldColumn,
                        columns: refTableColumns,
                        getMeta,
                        clientOrSqlUi,
                    }));
                }
            }
            break;
        case UITypes_1.default.Attachment:
            res.dataType = enums_1.FormulaDataTypes.STRING;
            break;
        case UITypes_1.default.Checkbox:
            if (col.dt === 'boolean' || col.dt === 'bool') {
                res.dataType = enums_1.FormulaDataTypes.BOOLEAN;
            }
            else {
                res.dataType = enums_1.FormulaDataTypes.NUMERIC;
            }
            break;
        case UITypes_1.default.Time:
            res.dataType = enums_1.FormulaDataTypes.INTERVAL;
            break;
        case UITypes_1.default.ID:
        case UITypes_1.default.ForeignKey:
        case UITypes_1.default.SpecificDBType:
            {
                if (sqlUI) {
                    const abstractType = sqlUI.getAbstractType(col);
                    if (['integer', 'float', 'decimal'].includes(abstractType)) {
                        res.dataType = enums_1.FormulaDataTypes.NUMERIC;
                    }
                    else if (['boolean'].includes(abstractType)) {
                        res.dataType = enums_1.FormulaDataTypes.BOOLEAN;
                    }
                    else if (['date', 'datetime', 'time', 'year'].includes(abstractType)) {
                        res.dataType = enums_1.FormulaDataTypes.DATE;
                    }
                    else {
                        res.dataType = enums_1.FormulaDataTypes.STRING;
                    }
                }
                else {
                    res.dataType = enums_1.FormulaDataTypes.UNKNOWN;
                }
            }
            break;
        // not supported
        case UITypes_1.default.Lookup:
        case UITypes_1.default.LinkToAnotherRecord:
            res.dataType = enums_1.FormulaDataTypes.ARRAY;
            break;
        case UITypes_1.default.Barcode:
        case UITypes_1.default.Button:
        case UITypes_1.default.Collaborator:
        case UITypes_1.default.QrCode:
        default:
            res.dataType = enums_1.FormulaDataTypes.UNKNOWN;
            break;
    }
    return res;
}
function handleBinaryExpressionForDateAndTime(params) {
    const { sourceBinaryNode } = params;
    let res;
    if ([enums_1.FormulaDataTypes.DATE, enums_1.FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.left.dataType) &&
        [enums_1.FormulaDataTypes.DATE, enums_1.FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.right.dataType) &&
        sourceBinaryNode.operator === '-') {
        // when it's interval and interval, we return diff in minute (numeric)
        if ([enums_1.FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.left.dataType) &&
            [enums_1.FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.right.dataType)) {
            res = {
                type: enums_1.JSEPNode.CALL_EXP,
                arguments: [
                    sourceBinaryNode.left,
                    sourceBinaryNode.right,
                    {
                        type: 'Literal',
                        value: 'minutes',
                        raw: '"minutes"',
                        dataType: 'string',
                    },
                ],
                callee: {
                    type: 'Identifier',
                    name: 'DATETIME_DIFF',
                },
                dataType: enums_1.FormulaDataTypes.NUMERIC,
            };
        }
        // when it's date - date, show the difference in minute
        else if ([enums_1.FormulaDataTypes.DATE].includes(sourceBinaryNode.left.dataType) &&
            [enums_1.FormulaDataTypes.DATE].includes(sourceBinaryNode.right.dataType)) {
            res = {
                type: enums_1.JSEPNode.CALL_EXP,
                arguments: [
                    sourceBinaryNode.left,
                    sourceBinaryNode.right,
                    {
                        type: 'Literal',
                        value: 'minutes',
                        raw: '"minutes"',
                        dataType: 'string',
                    },
                ],
                callee: {
                    type: 'Identifier',
                    name: 'DATETIME_DIFF',
                },
                dataType: enums_1.FormulaDataTypes.NUMERIC,
            };
        }
        // else interval and date can be addedd seamlessly A - B
        // with result as DATE
        // may be changed if we find other db use case
        else if ([enums_1.FormulaDataTypes.INTERVAL, enums_1.FormulaDataTypes.DATE].includes(sourceBinaryNode.left.dataType) &&
            [enums_1.FormulaDataTypes.INTERVAL, enums_1.FormulaDataTypes.DATE].includes(sourceBinaryNode.right.dataType) &&
            sourceBinaryNode.left.dataType != sourceBinaryNode.right.dataType) {
            res = {
                type: enums_1.JSEPNode.BINARY_EXP,
                left: sourceBinaryNode.left,
                right: sourceBinaryNode.right,
                operator: '-',
                dataType: enums_1.FormulaDataTypes.DATE,
            };
        }
    }
    else if ([enums_1.FormulaDataTypes.DATE, enums_1.FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.left.dataType) &&
        [enums_1.FormulaDataTypes.DATE, enums_1.FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.right.dataType) &&
        sourceBinaryNode.operator === '+') {
        // when it's interval and interval, we return addition in minute (numeric)
        if ([enums_1.FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.left.dataType) &&
            [enums_1.FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.right.dataType)) {
            const left = {
                type: enums_1.JSEPNode.CALL_EXP,
                arguments: [
                    sourceBinaryNode.left,
                    {
                        type: 'Literal',
                        value: '00:00:00',
                        raw: '"00:00:00"',
                        dataType: enums_1.FormulaDataTypes.INTERVAL,
                    },
                    {
                        type: 'Literal',
                        value: 'minutes',
                        raw: '"minutes"',
                        dataType: 'string',
                    },
                ],
                callee: {
                    type: 'Identifier',
                    name: 'DATETIME_DIFF',
                },
                dataType: enums_1.FormulaDataTypes.NUMERIC,
            };
            const right = {
                type: enums_1.JSEPNode.CALL_EXP,
                arguments: [
                    sourceBinaryNode.right,
                    {
                        type: 'Literal',
                        value: '00:00:00',
                        raw: '"00:00:00"',
                        dataType: enums_1.FormulaDataTypes.INTERVAL,
                    },
                    {
                        type: 'Literal',
                        value: 'minutes',
                        raw: '"minutes"',
                        dataType: 'string',
                    },
                ],
                callee: {
                    type: 'Identifier',
                    name: 'DATETIME_DIFF',
                },
                dataType: enums_1.FormulaDataTypes.NUMERIC,
            };
            return {
                type: enums_1.JSEPNode.BINARY_EXP,
                left,
                right,
                operator: '+',
                dataType: enums_1.FormulaDataTypes.NUMERIC,
            };
        }
        // else interval and date can be addedd seamlessly A + B
        // with result as DATE
        // may be changed if we find other db use case
        else if ([enums_1.FormulaDataTypes.INTERVAL, enums_1.FormulaDataTypes.DATE].includes(sourceBinaryNode.left.dataType) &&
            [enums_1.FormulaDataTypes.INTERVAL, enums_1.FormulaDataTypes.DATE].includes(sourceBinaryNode.right.dataType) &&
            sourceBinaryNode.left.dataType != sourceBinaryNode.right.dataType) {
            res = {
                type: enums_1.JSEPNode.BINARY_EXP,
                left: sourceBinaryNode.left,
                right: sourceBinaryNode.right,
                operator: '+',
                dataType: enums_1.FormulaDataTypes.DATE,
            };
        }
    }
    return res;
}
async function checkForCircularFormulaRef(formulaCol, parsedTree, columns, getMeta) {
    // Extract formula references
    const formulaPaths = await columns.reduce(async (promiseRes, c) => {
        const res = await promiseRes;
        if (c.id !== formulaCol.id && c.uidt === UITypes_1.default.Formula) {
            const neighbours = [
                ...new Set((c.colOptions.formula.match(/cl?_?\w{14,15}/g) || []).filter((colId) => columns.some((col) => col.id === colId && col.uidt === UITypes_1.default.Formula))),
            ];
            if (neighbours.length)
                res.push({ [c.id]: neighbours });
        }
        else if (c.uidt === UITypes_1.default.Lookup ||
            c.uidt === UITypes_1.default.LinkToAnotherRecord) {
            const neighbours = await processLookupOrLTARColumn(c);
            if (neighbours === null || neighbours === void 0 ? void 0 : neighbours.length)
                res.push({ [c.id]: neighbours });
        }
        return res;
    }, Promise.resolve([]));
    async function processLookupFormula(col, columns) {
        const neighbours = [];
        if (formulaCol.fk_model_id === col.fk_model_id) {
            return [col.id];
        }
        // Extract columns used in the formula and check for cycles
        const referencedColumns = col.colOptions.formula.match(/cl?_?\w{14,15}/g) || [];
        for (const refColId of referencedColumns) {
            const refCol = columns.find((c) => c.id === refColId);
            if (refCol.uidt === UITypes_1.default.Formula) {
                neighbours.push(...(await processLookupFormula(refCol, columns)));
            }
            else if (refCol.uidt === UITypes_1.default.Lookup ||
                refCol.uidt === UITypes_1.default.LinkToAnotherRecord) {
                neighbours.push(...(await processLookupOrLTARColumn(refCol)));
            }
        }
        return neighbours;
    }
    // Function to process lookup columns recursively
    async function processLookupOrLTARColumn(lookupOrLTARCol) {
        const neighbours = [];
        let ltarColumn;
        let lookupFilterFn;
        if (lookupOrLTARCol.uidt === UITypes_1.default.Lookup) {
            const relationColId = lookupOrLTARCol.colOptions
                .fk_relation_column_id;
            const lookupColId = lookupOrLTARCol.colOptions
                .fk_lookup_column_id;
            ltarColumn = columns.find((c) => c.id === relationColId);
            lookupFilterFn = (column) => column.id === lookupColId;
        }
        else if (lookupOrLTARCol.uidt === UITypes_1.default.LinkToAnotherRecord) {
            ltarColumn = lookupOrLTARCol;
            lookupFilterFn = (column) => !!column.pv;
        }
        if (ltarColumn) {
            const relatedTableMeta = await getMeta(ltarColumn.colOptions.fk_related_model_id);
            const lookupTarget = relatedTableMeta.columns.find(lookupFilterFn);
            if (lookupTarget) {
                if (lookupTarget.uidt === UITypes_1.default.Formula) {
                    neighbours.push(...(await processLookupFormula(lookupTarget, relatedTableMeta.columns)));
                }
                else if (lookupTarget.uidt === UITypes_1.default.Lookup ||
                    lookupTarget.uidt === UITypes_1.default.LinkToAnotherRecord) {
                    neighbours.push(...(await processLookupOrLTARColumn(lookupTarget)));
                }
            }
        }
        return [...new Set(neighbours)];
    }
    // include target formula column (i.e. the one to be saved if applicable)
    const targetFormulaCol = columns.find((c) => c.title === parsedTree.name &&
        [UITypes_1.default.Formula, UITypes_1.default.LinkToAnotherRecord, UITypes_1.default.Lookup].includes(c.uidt));
    if (targetFormulaCol && (formulaCol === null || formulaCol === void 0 ? void 0 : formulaCol.id)) {
        formulaPaths.push({
            [formulaCol === null || formulaCol === void 0 ? void 0 : formulaCol.id]: [targetFormulaCol.id],
        });
    }
    const vertices = formulaPaths.length;
    if (vertices > 0) {
        // perform kahn's algo for cycle detection
        const adj = new Map();
        const inDegrees = new Map();
        // init adjacency list & indegree
        for (const [_, v] of Object.entries(formulaPaths)) {
            const src = Object.keys(v)[0];
            const neighbours = v[src];
            inDegrees.set(src, inDegrees.get(src) || 0);
            for (const neighbour of neighbours) {
                adj.set(src, (adj.get(src) || new Set()).add(neighbour));
                inDegrees.set(neighbour, (inDegrees.get(neighbour) || 0) + 1);
            }
        }
        const queue = [];
        // put all vertices with in-degree = 0 (i.e. no incoming edges) to queue
        inDegrees.forEach((inDegree, col) => {
            if (inDegree === 0) {
                // in-degree = 0 means we start traversing from this node
                queue.push(col);
            }
        });
        // init count of visited vertices
        let visited = 0;
        // BFS
        while (queue.length !== 0) {
            // remove a vertex from the queue
            const src = queue.shift();
            // if this node has neighbours, increase visited by 1
            const neighbours = adj.get(src) || new Set();
            if (neighbours.size > 0) {
                visited += 1;
            }
            // iterate each neighbouring nodes
            neighbours.forEach((neighbour) => {
                // decrease in-degree of its neighbours by 1
                inDegrees.set(neighbour, inDegrees.get(neighbour) - 1);
                // if in-degree becomes 0
                if (inDegrees.get(neighbour) === 0) {
                    // then put the neighboring node to the queue
                    queue.push(neighbour);
                }
            });
        }
        // vertices not same as visited = cycle found
        if (vertices !== visited) {
            throw new error_1.FormulaError(enums_1.FormulaErrorType.CIRCULAR_REFERENCE, {
                key: 'msg.formula.cantSaveCircularReference',
            }, 'Circular reference detected');
        }
    }
}
async function validateFormulaAndExtractTreeWithType({ formula, column, columns, clientOrSqlUi, getMeta, trackPosition, }) {
    const sqlUI = typeof clientOrSqlUi === 'string'
        ? sqlUi_1.SqlUiFactory.create({ client: clientOrSqlUi })
        : clientOrSqlUi;
    const colAliasToColMap = {};
    const colIdToColMap = {};
    for (const col of columns) {
        colAliasToColMap[col.title] = col;
        colIdToColMap[col.id] = col;
    }
    const validateAndExtract = async (parsedTree) => {
        var _a, _b, _c, _d, _e, _f, _g;
        const res = Object.assign({}, parsedTree);
        if (parsedTree.type === enums_1.JSEPNode.CALL_EXP) {
            const calleeName = parsedTree.callee.name.toUpperCase();
            // validate function name
            if (!formulas_1.formulas[calleeName]) {
                throw new error_1.FormulaError(enums_1.FormulaErrorType.INVALID_FUNCTION_NAME, {
                    calleeName,
                    position: parsedTree.indexStart >= 0
                        ? {
                            index: parsedTree.indexStart,
                            length: parsedTree.nodeLength,
                        }
                        : undefined,
                }, `Function ${calleeName} is not available`);
            }
            else if (sqlUI === null || sqlUI === void 0 ? void 0 : sqlUI.getUnsupportedFnList().includes(calleeName)) {
                throw new error_1.FormulaError(enums_1.FormulaErrorType.INVALID_FUNCTION_NAME, {
                    calleeName,
                    position: parsedTree.indexStart >= 0
                        ? {
                            index: parsedTree.indexStart,
                            length: parsedTree.nodeLength,
                        }
                        : undefined,
                }, `Function ${calleeName} is unavailable for your database`);
            }
            // validate arguments
            const validation = formulas_1.formulas[calleeName] && formulas_1.formulas[calleeName].validation;
            if (validation && validation.args) {
                if (validation.args.rqd !== undefined &&
                    validation.args.rqd !== parsedTree.arguments.length) {
                    throw new error_1.FormulaError(enums_1.FormulaErrorType.INVALID_ARG, {
                        key: 'msg.formula.requiredArgumentsFormula',
                        requiredArguments: validation.args.rqd,
                        calleeName,
                        position: parsedTree.indexStart >= 0
                            ? {
                                index: parsedTree.indexStart,
                                length: parsedTree.nodeLength,
                            }
                            : undefined,
                    }, 'Required arguments missing');
                }
                else if (validation.args.min !== undefined &&
                    validation.args.min > parsedTree.arguments.length) {
                    throw new error_1.FormulaError(enums_1.FormulaErrorType.MIN_ARG, {
                        key: 'msg.formula.minRequiredArgumentsFormula',
                        minRequiredArguments: validation.args.min,
                        calleeName,
                        position: parsedTree.indexStart >= 0
                            ? {
                                index: parsedTree.indexStart,
                                length: parsedTree.nodeLength,
                            }
                            : undefined,
                    }, 'Minimum arguments required');
                }
                else if (validation.args.max !== undefined &&
                    validation.args.max < parsedTree.arguments.length) {
                    throw new error_1.FormulaError(enums_1.FormulaErrorType.INVALID_ARG, {
                        key: 'msg.formula.maxRequiredArgumentsFormula',
                        maxRequiredArguments: validation.args.max,
                        calleeName,
                        position: parsedTree.indexStart >= 0
                            ? {
                                index: parsedTree.indexStart,
                                length: parsedTree.nodeLength,
                            }
                            : undefined,
                    }, 'Maximum arguments missing');
                }
            }
            // get args type and validate
            const validateResult = (res.arguments =
                await Promise.all(parsedTree.arguments.map((arg) => {
                    return validateAndExtract(arg);
                })));
            const argTypes = validateResult.map((v) => v.dataType);
            // if validation function is present, call it
            if ((_a = formulas_1.formulas[calleeName].validation) === null || _a === void 0 ? void 0 : _a.custom) {
                (_b = formulas_1.formulas[calleeName].validation) === null || _b === void 0 ? void 0 : _b.custom(argTypes, parsedTree);
            }
            // validate against expected arg types if present
            else if ((_d = (_c = formulas_1.formulas[calleeName].validation) === null || _c === void 0 ? void 0 : _c.args) === null || _d === void 0 ? void 0 : _d.type) {
                for (let i = 0; i < validateResult.length; i++) {
                    const argPt = validateResult[i];
                    // if type
                    const expectedArgType = Array.isArray(formulas_1.formulas[calleeName].validation.args.type)
                        ? formulas_1.formulas[calleeName].validation.args.type[i]
                        : formulas_1.formulas[calleeName].validation.args.type;
                    if (argPt.dataType !== expectedArgType &&
                        argPt.dataType !== enums_1.FormulaDataTypes.NULL &&
                        argPt.dataType !== enums_1.FormulaDataTypes.UNKNOWN &&
                        expectedArgType !== enums_1.FormulaDataTypes.STRING) {
                        if (argPt.type === enums_1.JSEPNode.IDENTIFIER) {
                            const name = ((_e = columns === null || columns === void 0 ? void 0 : columns.find((c) => c.id === argPt.name || c.title === argPt.name)) === null || _e === void 0 ? void 0 : _e.title) || argPt.name;
                            throw new error_1.FormulaError(enums_1.FormulaErrorType.INVALID_ARG, {
                                key: 'msg.formula.columnWithTypeFoundButExpected',
                                columnName: name,
                                columnType: argPt.dataType,
                                expectedType: expectedArgType,
                            }, `Field ${name} with ${argPt.dataType} type is found but ${expectedArgType} type is expected`);
                        }
                        else {
                            let key = '';
                            const position = i + 1;
                            let type = '';
                            if (expectedArgType === enums_1.FormulaDataTypes.NUMERIC) {
                                key = 'msg.formula.typeIsExpected';
                                type = 'numeric';
                            }
                            else if (expectedArgType === enums_1.FormulaDataTypes.BOOLEAN) {
                                key = 'msg.formula.typeIsExpected';
                                type = 'boolean';
                            }
                            else if (expectedArgType === enums_1.FormulaDataTypes.DATE) {
                                key = 'msg.formula.typeIsExpected';
                                type = 'date';
                            }
                            throw new error_1.FormulaError(enums_1.FormulaErrorType.INVALID_ARG, {
                                type,
                                key,
                                position,
                                calleeName,
                            }, `${calleeName === null || calleeName === void 0 ? void 0 : calleeName.toUpperCase()} requires a ${type || expectedArgType} at position ${position}`);
                        }
                    }
                    // if expected type is string and arg type is not string, then cast it to string
                    if (expectedArgType === enums_1.FormulaDataTypes.STRING &&
                        expectedArgType !== argPt.dataType) {
                        argPt.cast = enums_1.FormulaDataTypes.STRING;
                    }
                }
            }
            if (typeof formulas_1.formulas[calleeName].returnType === 'function') {
                res.dataType = (_g = (_f = formulas_1.formulas[calleeName]).returnType) === null || _g === void 0 ? void 0 : _g.call(_f, argTypes);
            }
            else if (formulas_1.formulas[calleeName].returnType) {
                res.dataType = formulas_1.formulas[calleeName].returnType;
            }
        }
        else if (parsedTree.type === enums_1.JSEPNode.IDENTIFIER) {
            const identifierName = parsedTree.name;
            const col = (colIdToColMap[identifierName] ||
                colAliasToColMap[identifierName]);
            if (!col) {
                if (formulas_1.formulas[identifierName]) {
                    throw new error_1.FormulaError(enums_1.FormulaErrorType.INVALID_SYNTAX, {
                        key: 'msg.formula.formulaMissingParentheses',
                        calleeName: identifierName,
                        position: parsedTree.indexStart >= 0
                            ? {
                                index: parsedTree.indexEnd,
                                length: 1,
                            }
                            : undefined,
                    }, `Missing parentheses after function name "${JSON.stringify(identifierName)}"`);
                }
                throw new error_1.FormulaError(enums_1.FormulaErrorType.INVALID_COLUMN, {
                    key: 'msg.formula.columnNotAvailable',
                    columnName: identifierName,
                    position: parsedTree.indexStart >= 0
                        ? {
                            index: parsedTree.indexStart,
                            length: parsedTree.nodeLength,
                        }
                        : undefined,
                }, `Invalid column name/id ${JSON.stringify(identifierName)} in formula`);
            }
            res.name = col.id;
            if ((col === null || col === void 0 ? void 0 : col.uidt) === UITypes_1.default.Formula) {
                if (column) {
                    // check for circular reference when column is present(only available when calling root formula)
                    await checkForCircularFormulaRef(column, parsedTree, columns, getMeta);
                }
                const formulaRes = col.colOptions.parsed_tree ||
                    (await validateFormulaAndExtractTreeWithType(
                    // formula may include double curly brackets in previous version
                    // convert to single curly bracket here for compatibility
                    {
                        formula: col.colOptions.formula
                            .replaceAll('{{', '{')
                            .replaceAll('}}', '}'),
                        columns,
                        clientOrSqlUi,
                        getMeta,
                    }));
                res.dataType = formulaRes === null || formulaRes === void 0 ? void 0 : formulaRes.dataType;
            }
            else {
                if ((col === null || col === void 0 ? void 0 : col.uidt) === UITypes_1.default.Lookup ||
                    (col === null || col === void 0 ? void 0 : col.uidt) === UITypes_1.default.LinkToAnotherRecord) {
                    // check for circular reference when column is present(only available when calling root formula)
                    if (column) {
                        await checkForCircularFormulaRef(column, parsedTree, columns, getMeta);
                    }
                }
                // extract type and add to res
                Object.assign(res, await extractColumnIdentifierType({
                    col,
                    columns,
                    getMeta,
                    clientOrSqlUi,
                }));
            }
        }
        else if (parsedTree.type === enums_1.JSEPNode.LITERAL) {
            if (typeof parsedTree.value === 'number') {
                res.dataType = enums_1.FormulaDataTypes.NUMERIC;
            }
            else if (typeof parsedTree.value === 'string') {
                res.dataType = enums_1.FormulaDataTypes.STRING;
            }
            else if (typeof parsedTree.value === 'boolean') {
                res.dataType = enums_1.FormulaDataTypes.BOOLEAN;
            }
            else {
                res.dataType = enums_1.FormulaDataTypes.STRING;
            }
        }
        else if (parsedTree.type === enums_1.JSEPNode.UNARY_EXP) {
            // only support -ve values
            if (['-'].includes(parsedTree.operator) &&
                parsedTree.argument.type === enums_1.JSEPNode.LITERAL &&
                typeof parsedTree.argument.value === 'number') {
                res.dataType = enums_1.FormulaDataTypes.NUMERIC;
            }
            else {
                throw new error_1.FormulaError(enums_1.FormulaErrorType.NOT_SUPPORTED, {}, `Unary expression '${parsedTree.operator}' is not supported`);
            }
        }
        else if (parsedTree.type === enums_1.JSEPNode.BINARY_EXP) {
            res.left = await validateAndExtract(parsedTree.left);
            res.right = await validateAndExtract(parsedTree.right);
            const dateAndTimeParsedNode = handleBinaryExpressionForDateAndTime({
                sourceBinaryNode: res,
            });
            if (dateAndTimeParsedNode) {
                Object.assign(res, handleBinaryExpressionForDateAndTime({ sourceBinaryNode: res }));
                if (res.type !== enums_1.JSEPNode.BINARY_EXP) {
                    res.left = undefined;
                    res.right = undefined;
                    res.operator = undefined;
                }
            }
            else if (['==', '<', '>', '<=', '>=', '!='].includes(parsedTree.operator)) {
                res.dataType = enums_1.FormulaDataTypes.COND_EXP;
            }
            else if (parsedTree.operator === '+') {
                res.dataType = enums_1.FormulaDataTypes.NUMERIC;
                // if any side is string/date/other type, then the result will be concatenated string
                // e.g. 1 + '2' = '12'
                if ([
                    res.left,
                    res.right,
                ].some((r) => ![
                    enums_1.FormulaDataTypes.NUMERIC,
                    enums_1.FormulaDataTypes.BOOLEAN,
                    enums_1.FormulaDataTypes.NULL,
                    enums_1.FormulaDataTypes.UNKNOWN,
                ].includes(r.dataType))) {
                    res.dataType = enums_1.FormulaDataTypes.STRING;
                }
            }
            else if (['&'].includes(parsedTree.operator)) {
                res.dataType = enums_1.FormulaDataTypes.STRING;
            }
            else {
                res.dataType = enums_1.FormulaDataTypes.NUMERIC;
            }
        }
        else if (parsedTree.type === enums_1.JSEPNode.MEMBER_EXP) {
            throw new error_1.FormulaError(enums_1.FormulaErrorType.NOT_SUPPORTED, {}, 'Bracket notation is not supported');
        }
        else if (parsedTree.type === enums_1.JSEPNode.ARRAY_EXP) {
            throw new error_1.FormulaError(enums_1.FormulaErrorType.NOT_SUPPORTED, {}, 'Array is not supported');
        }
        else if (parsedTree.type === enums_1.JSEPNode.COMPOUND) {
            throw new error_1.FormulaError(enums_1.FormulaErrorType.NOT_SUPPORTED, {}, 'Compound statement is not supported');
        }
        return res;
    };
    try {
        // register jsep curly hook
        jsep_1.default.plugins.register(hooks_1.jsepCurlyHook);
        if (trackPosition) {
            jsep_1.default.plugins.register(hooks_1.jsepIndexHook);
        }
        const parsedFormula = (0, jsep_1.default)(formula);
        // TODO: better jsep expression handling
        const result = await validateAndExtract(parsedFormula);
        return result;
    }
    catch (ex) {
        if (trackPosition) {
            (0, handle_formula_error_1.handleFormulaError)({ formula, error: ex });
        }
        throw ex;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGUtZXh0cmFjdC10cmVlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi9mb3JtdWxhL3ZhbGlkYXRlLWV4dHJhY3QtdHJlZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQWtpQkEsc0ZBNGJDO0FBOTlCRCxnREFBd0I7QUFVeEIseURBQWlDO0FBQ2pDLG1DQUF1RTtBQUN2RSxtQ0FBdUM7QUFPdkMsb0NBQXdDO0FBQ3hDLGlFQUE0RDtBQUM1RCx5Q0FBc0M7QUFDdEMsbUNBQXVEO0FBY3ZELEtBQUssVUFBVSwyQkFBMkIsQ0FBQyxFQUN6QyxHQUFHLEVBQ0gsT0FBTyxFQUNQLE9BQU8sRUFDUCxhQUFhLEdBTWQ7SUFDQyxNQUFNLEdBQUcsR0FJTCxFQUFFLENBQUM7SUFDUCxNQUFNLEtBQUssR0FDVCxPQUFPLGFBQWEsS0FBSyxRQUFRO1FBQy9CLENBQUMsQ0FBQyxvQkFBWSxDQUFDLE1BQU0sQ0FBQyxFQUFFLE1BQU0sRUFBRSxhQUFhLEVBQUUsQ0FBQztRQUNoRCxDQUFDLENBQUMsYUFBYSxDQUFDO0lBRXBCLFFBQVEsR0FBRyxhQUFILEdBQUcsdUJBQUgsR0FBRyxDQUFFLElBQUksRUFBRSxDQUFDO1FBQ2xCLFNBQVM7UUFDVCxLQUFLLGlCQUFPLENBQUMsY0FBYyxDQUFDO1FBQzVCLEtBQUssaUJBQU8sQ0FBQyxRQUFRLENBQUM7UUFDdEIsS0FBSyxpQkFBTyxDQUFDLFdBQVcsQ0FBQztRQUN6QixLQUFLLGlCQUFPLENBQUMsWUFBWSxDQUFDO1FBQzFCLEtBQUssaUJBQU8sQ0FBQyxXQUFXLENBQUM7UUFDekIsS0FBSyxpQkFBTyxDQUFDLEtBQUssQ0FBQztRQUNuQixLQUFLLGlCQUFPLENBQUMsR0FBRyxDQUFDO1FBQ2pCLEtBQUssaUJBQU8sQ0FBQyxJQUFJLENBQUM7UUFDbEIsS0FBSyxpQkFBTyxDQUFDLFNBQVMsQ0FBQztRQUN2QixLQUFLLGlCQUFPLENBQUMsY0FBYztZQUN6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