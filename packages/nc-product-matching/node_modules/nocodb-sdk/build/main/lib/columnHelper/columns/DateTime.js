"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DateTimeHelper = void 0;
const dateTimeHelper_1 = require("../../../lib/dateTimeHelper");
const column_interface_1 = __importDefault(require("../column.interface"));
const utils_1 = require("../utils");
const error_1 = require("../../../lib/error");
const fill_handler_1 = require("../utils/fill-handler");
const helperFunctions_1 = require("../../../lib/helperFunctions");
const dayjs_1 = __importDefault(require("dayjs"));
const is_1 = require("../../../lib/is");
class DateTimeHelper extends column_interface_1.default {
    constructor() {
        super(...arguments);
        this.columnDefaultMeta = {
            date_format: dateTimeHelper_1.dateFormats[0],
            time_format: dateTimeHelper_1.timeFormats[0],
            is12hrFormat: false,
        };
    }
    serializeValue(value, params) {
        if (params.serializeSearchQuery)
            return null;
        value = (0, utils_1.serializeDateOrDateTimeValue)(value, params.col);
        if (value === null) {
            if (params.isMultipleCellPaste) {
                return null;
            }
            else {
                throw new error_1.SilentTypeConversionError();
            }
        }
        return value;
    }
    parseValue(value, params) {
        return (0, utils_1.parseDateTimeValue)(value, params);
    }
    parsePlainCellValue(value, params) {
        var _a;
        return (_a = (0, utils_1.parseDateTimeValue)(value, params)) !== null && _a !== void 0 ? _a : '';
    }
    populateFillHandle(params) {
        var _a;
        const { column, highlightedData, numberOfRows } = params;
        if (highlightedData.length < 2) {
            return (0, fill_handler_1.populateFillHandleStrictCopy)(params);
        }
        // data is in form like 'YYYY-MM-DD HH:mm' depends on meta dateformat
        const meta = (0, helperFunctions_1.parseProp)(column.meta);
        const metaDateFormat = (_a = meta.date_format) !== null && _a !== void 0 ? _a : 'YYYY-MM-DD';
        const metaTimeFormat = (0, dateTimeHelper_1.constructTimeFormat)(params.column);
        const dateTimeFormat = `${metaDateFormat} ${metaTimeFormat}`;
        let lastData;
        let modifier = undefined;
        let scale = 's';
        let canUseSecondScale = true;
        if (!dateTimeFormat.includes('ss')) {
            canUseSecondScale = false;
        }
        const setModifierForScaleIfRound = (currentData, lastData, diffScale) => {
            const currentModifier = currentData.diff(lastData, diffScale, true);
            if ((0, utils_1.isNumberRound)(currentModifier)) {
                scale = utils_1.DATE_DIFF_TO_SCALE_LABEL_MAP[diffScale];
                modifier = currentModifier;
            }
        };
        // map to dayjs
        const dayJsHighlightedData = [];
        for (const date of highlightedData) {
            if ((0, is_1.ncIsNullOrUndefined)(date) ||
                date === '' ||
                typeof date !== 'string') {
                return (0, fill_handler_1.populateFillHandleStrictCopy)(params);
            }
            const currentData = (0, dayjs_1.default)(date, dateTimeFormat);
            // unlikely on normal case
            if (!currentData.isValid()) {
                return (0, fill_handler_1.populateFillHandleStrictCopy)(params);
            }
            if (!lastData) {
                lastData = currentData;
            }
            else {
                if ((0, is_1.ncIsUndefined)(modifier)) {
                    const modifierInSeconds = currentData.diff(lastData, 'second');
                    if (modifierInSeconds > 60 * 60 * 24 * 354) {
                        setModifierForScaleIfRound(currentData, lastData, 'year');
                    }
                    else if (modifierInSeconds > 60 * 60 * 24 * 28) {
                        setModifierForScaleIfRound(currentData, lastData, 'month');
                    }
                    else if (modifierInSeconds > 60 * 60 * 24) {
                        setModifierForScaleIfRound(currentData, lastData, 'day');
                    }
                    else if (modifierInSeconds > 60 * 60) {
                        setModifierForScaleIfRound(currentData, lastData, 'hour');
                    }
                    else if (modifierInSeconds > 60) {
                        setModifierForScaleIfRound(currentData, lastData, 'minute');
                    }
                    else if (!canUseSecondScale) {
                        modifier = currentData.diff(lastData, 'minute');
                        scale = 'm';
                    }
                    else {
                        modifier = modifierInSeconds;
                        scale = 's';
                    }
                }
                else {
                    const currentModifier = currentData.diff(lastData, utils_1.DATE_SCALE_LABEL_TO_DIFF_MAP[scale]);
                    if (currentModifier !== modifier) {
                        return (0, fill_handler_1.populateFillHandleStrictCopy)(params);
                    }
                }
                lastData = currentData;
            }
            dayJsHighlightedData.push(lastData);
        }
        if (modifier === 0) {
            return (0, fill_handler_1.populateFillHandleStrictCopy)(params);
        }
        const numberToGenerate = numberOfRows - highlightedData.length;
        return Array.from({ length: numberToGenerate }).map(() => {
            const currentData = lastData.add(modifier, utils_1.DATE_SCALE_LABEL_TO_DIFF_MAP[scale]);
            lastData = currentData;
            return currentData.format(dateTimeFormat);
        });
    }
}
exports.DateTimeHelper = DateTimeHelper;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGF0ZVRpbWUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL2NvbHVtbkhlbHBlci9jb2x1bW5zL0RhdGVUaW1lLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLHlEQUk4QjtBQUM5QiwyRUFFNkI7QUFDN0Isb0NBTWtCO0FBQ2xCLHVDQUF3RDtBQUN4RCx3REFBcUU7QUFFckUsMkRBQWtEO0FBQ2xELGtEQUEwQjtBQUMxQixpQ0FBOEQ7QUFFOUQsTUFBYSxjQUFlLFNBQVEsMEJBQW9CO0lBQXhEOztRQUNFLHNCQUFpQixHQUFHO1lBQ2xCLFdBQVcsRUFBRSw0QkFBVyxDQUFDLENBQUMsQ0FBQztZQUMzQixXQUFXLEVBQUUsNEJBQVcsQ0FBQyxDQUFDLENBQUM7WUFDM0IsWUFBWSxFQUFFLEtBQUs7U0FDcEIsQ0FBQztJQTRJSixDQUFDO0lBMUlDLGNBQWMsQ0FDWixLQUFVLEVBQ1YsTUFBMkM7UUFFM0MsSUFBSSxNQUFNLENBQUMsb0JBQW9CO1lBQUUsT0FBTyxJQUFJLENBQUM7UUFFN0MsS0FBSyxHQUFHLElBQUEsb0NBQTRCLEVBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUV4RCxJQUFJLEtBQUssS0FBSyxJQUFJLEVBQUUsQ0FBQztZQUNuQixJQUFJLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO2dCQUMvQixPQUFPLElBQUksQ0FBQztZQUNkLENBQUM7aUJBQU0sQ0FBQztnQkFDTixNQUFNLElBQUksaUNBQXlCLEVBQUUsQ0FBQztZQUN4QyxDQUFDO1FBQ0gsQ0FBQztRQUVELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVELFVBQVUsQ0FDUixLQUFVLEVBQ1YsTUFBMkM7UUFFM0MsT0FBTyxJQUFBLDBCQUFrQixFQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQztJQUMzQyxDQUFDO0lBRUQsbUJBQW1CLENBQ2pCLEtBQVUsRUFDVixNQUEyQzs7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