var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import jsep from 'jsep';
import UITypes from '../UITypes';
import { FormulaDataTypes, FormulaErrorType, JSEPNode } from './enums';
import { FormulaError } from './error';
import { SqlUiFactory } from '../sqlUi';
import { handleFormulaError } from './handle-formula-error';
import { formulas } from './formulas';
import { jsepCurlyHook, jsepIndexHook } from './hooks';
function extractColumnIdentifierType(_a) {
    return __awaiter(this, arguments, void 0, function* ({ col, columns, getMeta, clientOrSqlUi, }) {
        const res = {};
        const sqlUI = typeof clientOrSqlUi === 'string'
            ? SqlUiFactory.create({ client: clientOrSqlUi })
            : clientOrSqlUi;
        switch (col === null || col === void 0 ? void 0 : col.uidt) {
            // string
            case UITypes.SingleLineText:
            case UITypes.LongText:
            case UITypes.MultiSelect:
            case UITypes.SingleSelect:
            case UITypes.PhoneNumber:
            case UITypes.Email:
            case UITypes.URL:
            case UITypes.User:
            case UITypes.CreatedBy:
            case UITypes.LastModifiedBy:
                res.dataType = FormulaDataTypes.STRING;
                break;
            // numeric
            case UITypes.Year:
            case UITypes.Number:
            case UITypes.Decimal:
            case UITypes.Rating:
            case UITypes.Count:
            case UITypes.AutoNumber:
                res.dataType = FormulaDataTypes.NUMERIC;
                break;
            // date
            case UITypes.Date:
            case UITypes.DateTime:
            case UITypes.CreatedTime:
            case UITypes.LastModifiedTime:
                res.dataType = FormulaDataTypes.DATE;
                break;
            case UITypes.Currency:
            case UITypes.Percent:
            case UITypes.Duration:
            case UITypes.Links:
                res.dataType = FormulaDataTypes.NUMERIC;
                break;
            case UITypes.Rollup:
                {
                    const rollupFunction = col.colOptions.rollup_function;
                    if ([
                        'count',
                        'avg',
                        'sum',
                        'countDistinct',
                        'sumDistinct',
                        'avgDistinct',
                    ].includes(rollupFunction)) {
                        // these functions produce a numeric value, which can be used in numeric functions
                        res.dataType = FormulaDataTypes.NUMERIC;
                    }
                    else {
                        const relationColumnOpt = columns.find((column) => column.id === col.colOptions.fk_relation_column_id);
                        // the value is based on the foreign rollup column type
                        const refTableMeta = yield getMeta(relationColumnOpt.colOptions
                            .fk_related_model_id);
                        const refTableColumns = refTableMeta.columns;
                        const childFieldColumn = refTableColumns.find((column) => column.id === col.colOptions.fk_rollup_column_id);
                        // extract type and add to res
                        Object.assign(res, yield extractColumnIdentifierType({
                            col: childFieldColumn,
                            columns: refTableColumns,
                            getMeta,
                            clientOrSqlUi,
                        }));
                    }
                }
                break;
            case UITypes.Attachment:
                res.dataType = FormulaDataTypes.STRING;
                break;
            case UITypes.Checkbox:
                if (col.dt === 'boolean' || col.dt === 'bool') {
                    res.dataType = FormulaDataTypes.BOOLEAN;
                }
                else {
                    res.dataType = FormulaDataTypes.NUMERIC;
                }
                break;
            case UITypes.Time:
                res.dataType = FormulaDataTypes.INTERVAL;
                break;
            case UITypes.ID:
            case UITypes.ForeignKey:
            case UITypes.SpecificDBType:
                {
                    if (sqlUI) {
                        const abstractType = sqlUI.getAbstractType(col);
                        if (['integer', 'float', 'decimal'].includes(abstractType)) {
                            res.dataType = FormulaDataTypes.NUMERIC;
                        }
                        else if (['boolean'].includes(abstractType)) {
                            res.dataType = FormulaDataTypes.BOOLEAN;
                        }
                        else if (['date', 'datetime', 'time', 'year'].includes(abstractType)) {
                            res.dataType = FormulaDataTypes.DATE;
                        }
                        else {
                            res.dataType = FormulaDataTypes.STRING;
                        }
                    }
                    else {
                        res.dataType = FormulaDataTypes.UNKNOWN;
                    }
                }
                break;
            // not supported
            case UITypes.Lookup:
            case UITypes.LinkToAnotherRecord:
                res.dataType = FormulaDataTypes.ARRAY;
                break;
            case UITypes.Barcode:
            case UITypes.Button:
            case UITypes.Collaborator:
            case UITypes.QrCode:
            default:
                res.dataType = FormulaDataTypes.UNKNOWN;
                break;
        }
        return res;
    });
}
function handleBinaryExpressionForDateAndTime(params) {
    const { sourceBinaryNode } = params;
    let res;
    if ([FormulaDataTypes.DATE, FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.left.dataType) &&
        [FormulaDataTypes.DATE, FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.right.dataType) &&
        sourceBinaryNode.operator === '-') {
        // when it's interval and interval, we return diff in minute (numeric)
        if ([FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.left.dataType) &&
            [FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.right.dataType)) {
            res = {
                type: JSEPNode.CALL_EXP,
                arguments: [
                    sourceBinaryNode.left,
                    sourceBinaryNode.right,
                    {
                        type: 'Literal',
                        value: 'minutes',
                        raw: '"minutes"',
                        dataType: 'string',
                    },
                ],
                callee: {
                    type: 'Identifier',
                    name: 'DATETIME_DIFF',
                },
                dataType: FormulaDataTypes.NUMERIC,
            };
        }
        // when it's date - date, show the difference in minute
        else if ([FormulaDataTypes.DATE].includes(sourceBinaryNode.left.dataType) &&
            [FormulaDataTypes.DATE].includes(sourceBinaryNode.right.dataType)) {
            res = {
                type: JSEPNode.CALL_EXP,
                arguments: [
                    sourceBinaryNode.left,
                    sourceBinaryNode.right,
                    {
                        type: 'Literal',
                        value: 'minutes',
                        raw: '"minutes"',
                        dataType: 'string',
                    },
                ],
                callee: {
                    type: 'Identifier',
                    name: 'DATETIME_DIFF',
                },
                dataType: FormulaDataTypes.NUMERIC,
            };
        }
        // else interval and date can be addedd seamlessly A - B
        // with result as DATE
        // may be changed if we find other db use case
        else if ([FormulaDataTypes.INTERVAL, FormulaDataTypes.DATE].includes(sourceBinaryNode.left.dataType) &&
            [FormulaDataTypes.INTERVAL, FormulaDataTypes.DATE].includes(sourceBinaryNode.right.dataType) &&
            sourceBinaryNode.left.dataType != sourceBinaryNode.right.dataType) {
            res = {
                type: JSEPNode.BINARY_EXP,
                left: sourceBinaryNode.left,
                right: sourceBinaryNode.right,
                operator: '-',
                dataType: FormulaDataTypes.DATE,
            };
        }
    }
    else if ([FormulaDataTypes.DATE, FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.left.dataType) &&
        [FormulaDataTypes.DATE, FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.right.dataType) &&
        sourceBinaryNode.operator === '+') {
        // when it's interval and interval, we return addition in minute (numeric)
        if ([FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.left.dataType) &&
            [FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.right.dataType)) {
            const left = {
                type: JSEPNode.CALL_EXP,
                arguments: [
                    sourceBinaryNode.left,
                    {
                        type: 'Literal',
                        value: '00:00:00',
                        raw: '"00:00:00"',
                        dataType: FormulaDataTypes.INTERVAL,
                    },
                    {
                        type: 'Literal',
                        value: 'minutes',
                        raw: '"minutes"',
                        dataType: 'string',
                    },
                ],
                callee: {
                    type: 'Identifier',
                    name: 'DATETIME_DIFF',
                },
                dataType: FormulaDataTypes.NUMERIC,
            };
            const right = {
                type: JSEPNode.CALL_EXP,
                arguments: [
                    sourceBinaryNode.right,
                    {
                        type: 'Literal',
                        value: '00:00:00',
                        raw: '"00:00:00"',
                        dataType: FormulaDataTypes.INTERVAL,
                    },
                    {
                        type: 'Literal',
                        value: 'minutes',
                        raw: '"minutes"',
                        dataType: 'string',
                    },
                ],
                callee: {
                    type: 'Identifier',
                    name: 'DATETIME_DIFF',
                },
                dataType: FormulaDataTypes.NUMERIC,
            };
            return {
                type: JSEPNode.BINARY_EXP,
                left,
                right,
                operator: '+',
                dataType: FormulaDataTypes.NUMERIC,
            };
        }
        // else interval and date can be addedd seamlessly A + B
        // with result as DATE
        // may be changed if we find other db use case
        else if ([FormulaDataTypes.INTERVAL, FormulaDataTypes.DATE].includes(sourceBinaryNode.left.dataType) &&
            [FormulaDataTypes.INTERVAL, FormulaDataTypes.DATE].includes(sourceBinaryNode.right.dataType) &&
            sourceBinaryNode.left.dataType != sourceBinaryNode.right.dataType) {
            res = {
                type: JSEPNode.BINARY_EXP,
                left: sourceBinaryNode.left,
                right: sourceBinaryNode.right,
                operator: '+',
                dataType: FormulaDataTypes.DATE,
            };
        }
    }
    return res;
}
function checkForCircularFormulaRef(formulaCol, parsedTree, columns, getMeta) {
    return __awaiter(this, void 0, void 0, function* () {
        // Extract formula references
        const formulaPaths = yield columns.reduce((promiseRes, c) => __awaiter(this, void 0, void 0, function* () {
            const res = yield promiseRes;
            if (c.id !== formulaCol.id && c.uidt === UITypes.Formula) {
                const neighbours = [
                    ...new Set((c.colOptions.formula.match(/cl?_?\w{14,15}/g) || []).filter((colId) => columns.some((col) => col.id === colId && col.uidt === UITypes.Formula))),
                ];
                if (neighbours.length)
                    res.push({ [c.id]: neighbours });
            }
            else if (c.uidt === UITypes.Lookup ||
                c.uidt === UITypes.LinkToAnotherRecord) {
                const neighbours = yield processLookupOrLTARColumn(c);
                if (neighbours === null || neighbours === void 0 ? void 0 : neighbours.length)
                    res.push({ [c.id]: neighbours });
            }
            return res;
        }), Promise.resolve([]));
        function processLookupFormula(col, columns) {
            return __awaiter(this, void 0, void 0, function* () {
                const neighbours = [];
                if (formulaCol.fk_model_id === col.fk_model_id) {
                    return [col.id];
                }
                // Extract columns used in the formula and check for cycles
                const referencedColumns = col.colOptions.formula.match(/cl?_?\w{14,15}/g) || [];
                for (const refColId of referencedColumns) {
                    const refCol = columns.find((c) => c.id === refColId);
                    if (refCol.uidt === UITypes.Formula) {
                        neighbours.push(...(yield processLookupFormula(refCol, columns)));
                    }
                    else if (refCol.uidt === UITypes.Lookup ||
                        refCol.uidt === UITypes.LinkToAnotherRecord) {
                        neighbours.push(...(yield processLookupOrLTARColumn(refCol)));
                    }
                }
                return neighbours;
            });
        }
        // Function to process lookup columns recursively
        function processLookupOrLTARColumn(lookupOrLTARCol) {
            return __awaiter(this, void 0, void 0, function* () {
                const neighbours = [];
                let ltarColumn;
                let lookupFilterFn;
                if (lookupOrLTARCol.uidt === UITypes.Lookup) {
                    const relationColId = lookupOrLTARCol.colOptions
                        .fk_relation_column_id;
                    const lookupColId = lookupOrLTARCol.colOptions
                        .fk_lookup_column_id;
                    ltarColumn = columns.find((c) => c.id === relationColId);
                    lookupFilterFn = (column) => column.id === lookupColId;
                }
                else if (lookupOrLTARCol.uidt === UITypes.LinkToAnotherRecord) {
                    ltarColumn = lookupOrLTARCol;
                    lookupFilterFn = (column) => !!column.pv;
                }
                if (ltarColumn) {
                    const relatedTableMeta = yield getMeta(ltarColumn.colOptions.fk_related_model_id);
                    const lookupTarget = relatedTableMeta.columns.find(lookupFilterFn);
                    if (lookupTarget) {
                        if (lookupTarget.uidt === UITypes.Formula) {
                            neighbours.push(...(yield processLookupFormula(lookupTarget, relatedTableMeta.columns)));
                        }
                        else if (lookupTarget.uidt === UITypes.Lookup ||
                            lookupTarget.uidt === UITypes.LinkToAnotherRecord) {
                            neighbours.push(...(yield processLookupOrLTARColumn(lookupTarget)));
                        }
                    }
                }
                return [...new Set(neighbours)];
            });
        }
        // include target formula column (i.e. the one to be saved if applicable)
        const targetFormulaCol = columns.find((c) => c.title === parsedTree.name &&
            [UITypes.Formula, UITypes.LinkToAnotherRecord, UITypes.Lookup].includes(c.uidt));
        if (targetFormulaCol && (formulaCol === null || formulaCol === void 0 ? void 0 : formulaCol.id)) {
            formulaPaths.push({
                [formulaCol === null || formulaCol === void 0 ? void 0 : formulaCol.id]: [targetFormulaCol.id],
            });
        }
        const vertices = formulaPaths.length;
        if (vertices > 0) {
            // perform kahn's algo for cycle detection
            const adj = new Map();
            const inDegrees = new Map();
            // init adjacency list & indegree
            for (const [_, v] of Object.entries(formulaPaths)) {
                const src = Object.keys(v)[0];
                const neighbours = v[src];
                inDegrees.set(src, inDegrees.get(src) || 0);
                for (const neighbour of neighbours) {
                    adj.set(src, (adj.get(src) || new Set()).add(neighbour));
                    inDegrees.set(neighbour, (inDegrees.get(neighbour) || 0) + 1);
                }
            }
            const queue = [];
            // put all vertices with in-degree = 0 (i.e. no incoming edges) to queue
            inDegrees.forEach((inDegree, col) => {
                if (inDegree === 0) {
                    // in-degree = 0 means we start traversing from this node
                    queue.push(col);
                }
            });
            // init count of visited vertices
            let visited = 0;
            // BFS
            while (queue.length !== 0) {
                // remove a vertex from the queue
                const src = queue.shift();
                // if this node has neighbours, increase visited by 1
                const neighbours = adj.get(src) || new Set();
                if (neighbours.size > 0) {
                    visited += 1;
                }
                // iterate each neighbouring nodes
                neighbours.forEach((neighbour) => {
                    // decrease in-degree of its neighbours by 1
                    inDegrees.set(neighbour, inDegrees.get(neighbour) - 1);
                    // if in-degree becomes 0
                    if (inDegrees.get(neighbour) === 0) {
                        // then put the neighboring node to the queue
                        queue.push(neighbour);
                    }
                });
            }
            // vertices not same as visited = cycle found
            if (vertices !== visited) {
                throw new FormulaError(FormulaErrorType.CIRCULAR_REFERENCE, {
                    key: 'msg.formula.cantSaveCircularReference',
                }, 'Circular reference detected');
            }
        }
    });
}
export function validateFormulaAndExtractTreeWithType(_a) {
    return __awaiter(this, arguments, void 0, function* ({ formula, column, columns, clientOrSqlUi, getMeta, trackPosition, }) {
        const sqlUI = typeof clientOrSqlUi === 'string'
            ? SqlUiFactory.create({ client: clientOrSqlUi })
            : clientOrSqlUi;
        const colAliasToColMap = {};
        const colIdToColMap = {};
        for (const col of columns) {
            colAliasToColMap[col.title] = col;
            colIdToColMap[col.id] = col;
        }
        const validateAndExtract = (parsedTree) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g;
            const res = Object.assign({}, parsedTree);
            if (parsedTree.type === JSEPNode.CALL_EXP) {
                const calleeName = parsedTree.callee.name.toUpperCase();
                // validate function name
                if (!formulas[calleeName]) {
                    throw new FormulaError(FormulaErrorType.INVALID_FUNCTION_NAME, {
                        calleeName,
                        position: parsedTree.indexStart >= 0
                            ? {
                                index: parsedTree.indexStart,
                                length: parsedTree.nodeLength,
                            }
                            : undefined,
                    }, `Function ${calleeName} is not available`);
                }
                else if (sqlUI === null || sqlUI === void 0 ? void 0 : sqlUI.getUnsupportedFnList().includes(calleeName)) {
                    throw new FormulaError(FormulaErrorType.INVALID_FUNCTION_NAME, {
                        calleeName,
                        position: parsedTree.indexStart >= 0
                            ? {
                                index: parsedTree.indexStart,
                                length: parsedTree.nodeLength,
                            }
                            : undefined,
                    }, `Function ${calleeName} is unavailable for your database`);
                }
                // validate arguments
                const validation = formulas[calleeName] && formulas[calleeName].validation;
                if (validation && validation.args) {
                    if (validation.args.rqd !== undefined &&
                        validation.args.rqd !== parsedTree.arguments.length) {
                        throw new FormulaError(FormulaErrorType.INVALID_ARG, {
                            key: 'msg.formula.requiredArgumentsFormula',
                            requiredArguments: validation.args.rqd,
                            calleeName,
                            position: parsedTree.indexStart >= 0
                                ? {
                                    index: parsedTree.indexStart,
                                    length: parsedTree.nodeLength,
                                }
                                : undefined,
                        }, 'Required arguments missing');
                    }
                    else if (validation.args.min !== undefined &&
                        validation.args.min > parsedTree.arguments.length) {
                        throw new FormulaError(FormulaErrorType.MIN_ARG, {
                            key: 'msg.formula.minRequiredArgumentsFormula',
                            minRequiredArguments: validation.args.min,
                            calleeName,
                            position: parsedTree.indexStart >= 0
                                ? {
                                    index: parsedTree.indexStart,
                                    length: parsedTree.nodeLength,
                                }
                                : undefined,
                        }, 'Minimum arguments required');
                    }
                    else if (validation.args.max !== undefined &&
                        validation.args.max < parsedTree.arguments.length) {
                        throw new FormulaError(FormulaErrorType.INVALID_ARG, {
                            key: 'msg.formula.maxRequiredArgumentsFormula',
                            maxRequiredArguments: validation.args.max,
                            calleeName,
                            position: parsedTree.indexStart >= 0
                                ? {
                                    index: parsedTree.indexStart,
                                    length: parsedTree.nodeLength,
                                }
                                : undefined,
                        }, 'Maximum arguments missing');
                    }
                }
                // get args type and validate
                const validateResult = (res.arguments =
                    yield Promise.all(parsedTree.arguments.map((arg) => {
                        return validateAndExtract(arg);
                    })));
                const argTypes = validateResult.map((v) => v.dataType);
                // if validation function is present, call it
                if ((_a = formulas[calleeName].validation) === null || _a === void 0 ? void 0 : _a.custom) {
                    (_b = formulas[calleeName].validation) === null || _b === void 0 ? void 0 : _b.custom(argTypes, parsedTree);
                }
                // validate against expected arg types if present
                else if ((_d = (_c = formulas[calleeName].validation) === null || _c === void 0 ? void 0 : _c.args) === null || _d === void 0 ? void 0 : _d.type) {
                    for (let i = 0; i < validateResult.length; i++) {
                        const argPt = validateResult[i];
                        // if type
                        const expectedArgType = Array.isArray(formulas[calleeName].validation.args.type)
                            ? formulas[calleeName].validation.args.type[i]
                            : formulas[calleeName].validation.args.type;
                        if (argPt.dataType !== expectedArgType &&
                            argPt.dataType !== FormulaDataTypes.NULL &&
                            argPt.dataType !== FormulaDataTypes.UNKNOWN &&
                            expectedArgType !== FormulaDataTypes.STRING) {
                            if (argPt.type === JSEPNode.IDENTIFIER) {
                                const name = ((_e = columns === null || columns === void 0 ? void 0 : columns.find((c) => c.id === argPt.name || c.title === argPt.name)) === null || _e === void 0 ? void 0 : _e.title) || argPt.name;
                                throw new FormulaError(FormulaErrorType.INVALID_ARG, {
                                    key: 'msg.formula.columnWithTypeFoundButExpected',
                                    columnName: name,
                                    columnType: argPt.dataType,
                                    expectedType: expectedArgType,
                                }, `Field ${name} with ${argPt.dataType} type is found but ${expectedArgType} type is expected`);
                            }
                            else {
                                let key = '';
                                const position = i + 1;
                                let type = '';
                                if (expectedArgType === FormulaDataTypes.NUMERIC) {
                                    key = 'msg.formula.typeIsExpected';
                                    type = 'numeric';
                                }
                                else if (expectedArgType === FormulaDataTypes.BOOLEAN) {
                                    key = 'msg.formula.typeIsExpected';
                                    type = 'boolean';
                                }
                                else if (expectedArgType === FormulaDataTypes.DATE) {
                                    key = 'msg.formula.typeIsExpected';
                                    type = 'date';
                                }
                                throw new FormulaError(FormulaErrorType.INVALID_ARG, {
                                    type,
                                    key,
                                    position,
                                    calleeName,
                                }, `${calleeName === null || calleeName === void 0 ? void 0 : calleeName.toUpperCase()} requires a ${type || expectedArgType} at position ${position}`);
                            }
                        }
                        // if expected type is string and arg type is not string, then cast it to string
                        if (expectedArgType === FormulaDataTypes.STRING &&
                            expectedArgType !== argPt.dataType) {
                            argPt.cast = FormulaDataTypes.STRING;
                        }
                    }
                }
                if (typeof formulas[calleeName].returnType === 'function') {
                    res.dataType = (_g = (_f = formulas[calleeName]).returnType) === null || _g === void 0 ? void 0 : _g.call(_f, argTypes);
                }
                else if (formulas[calleeName].returnType) {
                    res.dataType = formulas[calleeName].returnType;
                }
            }
            else if (parsedTree.type === JSEPNode.IDENTIFIER) {
                const identifierName = parsedTree.name;
                const col = (colIdToColMap[identifierName] ||
                    colAliasToColMap[identifierName]);
                if (!col) {
                    if (formulas[identifierName]) {
                        throw new FormulaError(FormulaErrorType.INVALID_SYNTAX, {
                            key: 'msg.formula.formulaMissingParentheses',
                            calleeName: identifierName,
                            position: parsedTree.indexStart >= 0
                                ? {
                                    index: parsedTree.indexEnd,
                                    length: 1,
                                }
                                : undefined,
                        }, `Missing parentheses after function name "${JSON.stringify(identifierName)}"`);
                    }
                    throw new FormulaError(FormulaErrorType.INVALID_COLUMN, {
                        key: 'msg.formula.columnNotAvailable',
                        columnName: identifierName,
                        position: parsedTree.indexStart >= 0
                            ? {
                                index: parsedTree.indexStart,
                                length: parsedTree.nodeLength,
                            }
                            : undefined,
                    }, `Invalid column name/id ${JSON.stringify(identifierName)} in formula`);
                }
                res.name = col.id;
                if ((col === null || col === void 0 ? void 0 : col.uidt) === UITypes.Formula) {
                    if (column) {
                        // check for circular reference when column is present(only available when calling root formula)
                        yield checkForCircularFormulaRef(column, parsedTree, columns, getMeta);
                    }
                    const formulaRes = col.colOptions.parsed_tree ||
                        (yield validateFormulaAndExtractTreeWithType(
                        // formula may include double curly brackets in previous version
                        // convert to single curly bracket here for compatibility
                        {
                            formula: col.colOptions.formula
                                .replaceAll('{{', '{')
                                .replaceAll('}}', '}'),
                            columns,
                            clientOrSqlUi,
                            getMeta,
                        }));
                    res.dataType = formulaRes === null || formulaRes === void 0 ? void 0 : formulaRes.dataType;
                }
                else {
                    if ((col === null || col === void 0 ? void 0 : col.uidt) === UITypes.Lookup ||
                        (col === null || col === void 0 ? void 0 : col.uidt) === UITypes.LinkToAnotherRecord) {
                        // check for circular reference when column is present(only available when calling root formula)
                        if (column) {
                            yield checkForCircularFormulaRef(column, parsedTree, columns, getMeta);
                        }
                    }
                    // extract type and add to res
                    Object.assign(res, yield extractColumnIdentifierType({
                        col,
                        columns,
                        getMeta,
                        clientOrSqlUi,
                    }));
                }
            }
            else if (parsedTree.type === JSEPNode.LITERAL) {
                if (typeof parsedTree.value === 'number') {
                    res.dataType = FormulaDataTypes.NUMERIC;
                }
                else if (typeof parsedTree.value === 'string') {
                    res.dataType = FormulaDataTypes.STRING;
                }
                else if (typeof parsedTree.value === 'boolean') {
                    res.dataType = FormulaDataTypes.BOOLEAN;
                }
                else {
                    res.dataType = FormulaDataTypes.STRING;
                }
            }
            else if (parsedTree.type === JSEPNode.UNARY_EXP) {
                // only support -ve values
                if (['-'].includes(parsedTree.operator) &&
                    parsedTree.argument.type === JSEPNode.LITERAL &&
                    typeof parsedTree.argument.value === 'number') {
                    res.dataType = FormulaDataTypes.NUMERIC;
                }
                else {
                    throw new FormulaError(FormulaErrorType.NOT_SUPPORTED, {}, `Unary expression '${parsedTree.operator}' is not supported`);
                }
            }
            else if (parsedTree.type === JSEPNode.BINARY_EXP) {
                res.left = yield validateAndExtract(parsedTree.left);
                res.right = yield validateAndExtract(parsedTree.right);
                const dateAndTimeParsedNode = handleBinaryExpressionForDateAndTime({
                    sourceBinaryNode: res,
                });
                if (dateAndTimeParsedNode) {
                    Object.assign(res, handleBinaryExpressionForDateAndTime({ sourceBinaryNode: res }));
                    if (res.type !== JSEPNode.BINARY_EXP) {
                        res.left = undefined;
                        res.right = undefined;
                        res.operator = undefined;
                    }
                }
                else if (['==', '<', '>', '<=', '>=', '!='].includes(parsedTree.operator)) {
                    res.dataType = FormulaDataTypes.COND_EXP;
                }
                else if (parsedTree.operator === '+') {
                    res.dataType = FormulaDataTypes.NUMERIC;
                    // if any side is string/date/other type, then the result will be concatenated string
                    // e.g. 1 + '2' = '12'
                    if ([
                        res.left,
                        res.right,
                    ].some((r) => ![
                        FormulaDataTypes.NUMERIC,
                        FormulaDataTypes.BOOLEAN,
                        FormulaDataTypes.NULL,
                        FormulaDataTypes.UNKNOWN,
                    ].includes(r.dataType))) {
                        res.dataType = FormulaDataTypes.STRING;
                    }
                }
                else if (['&'].includes(parsedTree.operator)) {
                    res.dataType = FormulaDataTypes.STRING;
                }
                else {
                    res.dataType = FormulaDataTypes.NUMERIC;
                }
            }
            else if (parsedTree.type === JSEPNode.MEMBER_EXP) {
                throw new FormulaError(FormulaErrorType.NOT_SUPPORTED, {}, 'Bracket notation is not supported');
            }
            else if (parsedTree.type === JSEPNode.ARRAY_EXP) {
                throw new FormulaError(FormulaErrorType.NOT_SUPPORTED, {}, 'Array is not supported');
            }
            else if (parsedTree.type === JSEPNode.COMPOUND) {
                throw new FormulaError(FormulaErrorType.NOT_SUPPORTED, {}, 'Compound statement is not supported');
            }
            return res;
        });
        try {
            // register jsep curly hook
            jsep.plugins.register(jsepCurlyHook);
            if (trackPosition) {
                jsep.plugins.register(jsepIndexHook);
            }
            const parsedFormula = jsep(formula);
            // TODO: better jsep expression handling
            const result = yield validateAndExtract(parsedFormula);
            return result;
        }
        catch (ex) {
            if (trackPosition) {
                handleFormulaError({ formula, error: ex });
            }
            throw ex;
        }
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGUtZXh0cmFjdC10cmVlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi9mb3JtdWxhL3ZhbGlkYXRlLWV4dHJhY3QtdHJlZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSxPQUFPLElBQUksTUFBTSxNQUFNLENBQUM7QUFVeEIsT0FBTyxPQUFPLE1BQU0sWUFBWSxDQUFDO0FBQ2pDLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxnQkFBZ0IsRUFBRSxRQUFRLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFDdkUsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLFNBQVMsQ0FBQztBQU92QyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBQ3hDLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQzVELE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDdEMsT0FBTyxFQUFFLGFBQWEsRUFBRSxhQUFhLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFjdkQsU0FBZSwyQkFBMkI7eURBQUMsRUFDekMsR0FBRyxFQUNILE9BQU8sRUFDUCxPQUFPLEVBQ1AsYUFBYSxHQU1kO1FBQ0MsTUFBTSxHQUFHLEdBSUwsRUFBRSxDQUFDO1FBQ1AsTUFBTSxLQUFLLEdBQ1QsT0FBTyxhQUFhLEtBQUssUUFBUTtZQUMvQixDQUFDLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxFQUFFLE1BQU0sRUFBRSxhQUFhLEVBQUUsQ0FBQztZQUNoRCxDQUFDLENBQUMsYUFBYSxDQUFDO1FBRXBCLFFBQVEsR0FBRyxhQUFILEdBQUcsdUJBQUgsR0FBRyxDQUFFLElBQUksRUFBRSxDQUFDO1lBQ2xCLFNBQVM7WUFDVCxLQUFLLE9BQU8sQ0FBQyxjQUFjLENBQUM7WUFDNUIsS0FBSyxPQUFPLENBQUMsUUFBUSxDQUFDO1lBQ3RCLEtBQUssT0FBTyxDQUFDLFdBQVcsQ0FBQztZQUN6QixLQUFLLE9BQU8sQ0FBQyxZQUFZLENBQUM7WUFDMUIsS0FBSyxPQUFPLENBQUMsV0FBVyxDQUFDO1lBQ3pCLEtBQUssT0FBTyxDQUFDLEtBQUssQ0FBQztZQUNuQixLQUFLLE9BQU8sQ0FBQyxHQUFHLENBQUM7WUFDakIsS0FBSyxPQUFPLENBQUMsSUFBSSxDQUFDO1lBQ2xCLEtBQUssT0FBTyxDQUFDLFNBQVMsQ0FBQztZQUN2QixLQUFLLE9BQU8sQ0FBQyxjQUFjO2dCQUN6QixHQUFHLENBQUMsUUFBUSxHQUFHLGdCQUFnQixDQUFDLE1BQU0sQ0FBQztnQkFDdkMsTUFBTTtZQUNSLFVBQVU7WUFDVixLQUFLLE9BQU8sQ0FBQyxJQUFJLENBQUM7WUFDbEIsS0FBSyxPQUFPLENBQUMsTUFBTSxDQUFDO1lBQ3BCLEtBQUssT0FBTyxDQUFDLE9BQU8sQ0FBQztZQUNyQixLQUFLLE9BQU8sQ0FBQyxNQUFNLENBQUM7WUFDcEIsS0FBSyxPQUFPLENBQUMsS0FBSyxDQUFDO1lBQ25CLEtBQUssT0FBTyxDQUFDLFVBQVU7Z0JBQ3JCLEdBQUcsQ0FBQyxRQUFRLEdBQUcsZ0JBQWdCLENBQUMsT0FBTyxDQUFDO2dCQUN4QyxNQUFNO1lBQ1IsT0FBTztZQUNQLEtBQUssT0FBTyxDQUFDLElBQUksQ0FBQztZQUNsQixLQUFLLE9BQU8sQ0FBQyxRQUFRLENBQUM7WUFDdEIsS0FBSyxPQUFPLENBQUMsV0FBVyxDQUFDO1lBQ3pCLEtBQUssT0FBTyxDQUFDLGdCQUFnQjtnQkFDM0IsR0FBRyxDQUFDLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUM7Z0JBQ3JDLE1BQU07WUFFUixLQUFLLE9BQU8sQ0FBQyxRQUFRLENBQUM7WUFDdEIsS0FBSyxPQUFPLENBQUMsT0FBTyxDQUFDO1lBQ3JCLEtBQUssT0FBTyxDQUFDLFFBQVEsQ0FBQztZQUN0QixLQUFLLE9BQU8sQ0FBQyxLQUFLO2dCQUNoQixHQUFHLENBQUMsUUFBUSxHQUFHLGdCQUFnQixDQUFDLE9BQU8sQ0FBQztnQkFDeEMsTUFBTTtZQUVSLEtBQUssT0FBTyxDQUFDLE1BQU07Z0JBQ2pCLENBQUM7b0JBQ0MsTUFBTSxjQUFjLEdBQUcsR0FBRyxDQUFDLFVBQVUsQ0FBQyxlQUFlLENBQUM7b0JBQ3RELElBQ0U7d0JBQ0UsT0FBTzt3QkFDUCxLQUFLO3dCQUNMLEtBQUs7d0JBQ0wsZUFBZTt3QkFDZixhQUFhO3dCQUNiLGFBQWE7cUJBQ2QsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLEVBQzFCLENBQUM7d0JBQ0Qsa0ZBQWtGO3dCQUNsRixHQUFHLENBQUMsUUFBUSxHQUFHLGdCQUFnQixDQUFDLE9BQU8sQ0FBQztvQkFDMUMsQ0FBQzt5QkFBTSxDQUFDO3dCQUNOLE1BQU0saUJBQWlCLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FDcEMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUNULE1BQU0sQ0FBQyxFQUFFLEtBQWtCLEdBQUcsQ0FBQyxVQUFXLENBQUMscUJBQXFCLENBQ25FLENBQUM7d0JBRUYsdURBQXVEO3dCQUN2RCxNQUFNLFlBQVksR0FBRyxNQUFNLE9BQU8sQ0FDTixpQkFBaUIsQ0FBQyxVQUFXOzZCQUNwRCxtQkFBbUIsQ0FDdkIsQ0FBQzt3QkFFRixNQUFNLGVBQWUsR0FBRyxZQUFZLENBQUMsT0FBTyxDQUFDO3dCQUM3QyxNQUFNLGdCQUFnQixHQUFHLGVBQWUsQ0FBQyxJQUFJLENBQzNDLENBQUMsTUFBa0IsRUFBRSxFQUFFLENBQ3JCLE1BQU0sQ0FBQyxFQUFFLEtBQUssR0FBRyxDQUFDLFVBQVUsQ0FBQyxtQkFBbUIsQ0FDbkQsQ0FBQzt3QkFFRiw4QkFBOEI7d0JBQzlCLE1BQU0sQ0FBQyxNQUFNLENBQ1gsR0FBRyxFQUNILE1BQU0sMkJBQTJCLENBQUM7NEJBQ2hDLEdBQUcsRUFBRSxnQkFBZ0I7NEJBQ3JCLE9BQU8sRUFBRSxlQUFlOzRCQUN4QixPQUFPOzRCQUNQLGFBQWE7eUJBQ2QsQ0FBQyxDQUNILENBQUM7b0JBQ0osQ0FBQztnQkFDSCxDQUFDO2dCQUNELE1BQU07WUFFUixLQUFLLE9BQU8sQ0FBQyxVQUFVO2dCQUNyQixHQUFHLENBQUMsUUFBUSxHQUFHLGdCQUFnQixDQUFDLE1BQU0sQ0FBQztnQkFDdkMsTUFBTTtZQUNSLEtBQUssT0FBTyxDQUFDLFFBQVE7Z0JBQ25CLElBQUksR0FBRyxDQUFDLEVBQUUsS0FBSyxTQUFTLElBQUksR0FBRyxDQUFDLEVBQUUsS0FBSyxNQUFNLEVBQUUsQ0FBQztvQkFDOUMsR0FBRyxDQUFDLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUM7Z0JBQzFDLENBQUM7cUJBQU0sQ0FBQztvQkFDTixHQUFHLENBQUMsUUFBUSxHQUFHLGdCQUFnQixDQUFDLE9BQU8sQ0FBQztnQkFDMUMsQ0FBQztnQkFDRCxNQUFNO1lBQ1IsS0FBSyxPQUFPLENBQUMsSUFBSTtnQkFDZixHQUFHLENBQUMsUUFBUSxHQUFHLGdCQUFnQixDQUFDLFFBQVEsQ0FBQztnQkFDekMsTUFBTTtZQUNSLEtBQUssT0FBTyxDQUFDLEVBQUUsQ0FBQztZQUNoQixLQUFLLE9BQU8sQ0FBQyxVQUFVLENBQUM7WUFDeEIsS0FBSyxPQUFPLENBQUMsY0FBYztnQkFDekIsQ0FBQztvQkFDQyxJQUFJLEtBQUssRUFBRSxDQUFDO3dCQUNWLE1BQU0sWUFBWSxHQUFHLEtBQUssQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLENBQUM7d0JBQ2hELElBQUksQ0FBQyxTQUFTLEVBQUUsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDOzRCQUMzRCxHQUFHLENBQUMsUUFBUSxHQUFHLGdCQUFnQixDQUFDLE9BQU8sQ0FBQzt3QkFDMUMsQ0FBQzs2QkFBTSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUM7NEJBQzlDLEdBQUcsQ0FBQyxRQUFRLEdBQUcsZ0JBQWdCLENBQUMsT0FBTyxDQUFDO3dCQUMxQyxDQUFDOzZCQUFNLElBQ0wsQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLEVBQzNELENBQUM7NEJBQ0QsR0FBRyxDQUFDLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUM7d0JBQ3ZDLENBQUM7NkJBQU0sQ0FBQzs0QkFDTixHQUFHLENBQUMsUUFBUSxHQUFHLGdCQUFnQixDQUFDLE1BQU0sQ0FBQzt3QkFDekMsQ0FBQztvQkFDSCxDQUFDO3lCQUFNLENBQUM7d0JBQ04sR0FBRyxDQUFDLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUM7b0JBQzFDLENBQUM7Z0JBQ0gsQ0FBQztnQkFDRCxNQUFNO1lBQ1IsZ0JBQWdCO1lBQ2hCLEtBQUssT0FBTyxDQUFDLE1BQU0sQ0FBQztZQUNwQixLQUFLLE9BQU8sQ0FBQyxtQkFBbUI7Z0JBQzlCLEdBQUcsQ0FBQyxRQUFRLEdBQUcsZ0JBQWdCLENBQUMsS0FBSyxDQUFDO2dCQUN0QyxNQUFNO1lBQ1IsS0FBSyxPQUFPLENBQUMsT0FBTyxDQUFDO1lBQ3JCLEtBQUssT0FBTyxDQUFDLE1BQU0sQ0FBQztZQUNwQixLQUFLLE9BQU8sQ0FBQyxZQUFZLENBQUM7WUFDMUIsS0FBSyxPQUFPLENBQUMsTUFBTSxDQUFDO1lBQ3BCO2dCQUNFLEdBQUcsQ0FBQyxRQUFRLEdBQUcsZ0JBQWdCLENBQUMsT0FBTyxDQUFDO2dCQUN4QyxNQUFNO1FBQ1YsQ0FBQztRQUVELE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQztDQUFBO0FBRUQsU0FBUyxvQ0FBb0MsQ0FBQyxNQUU3QztJQUNDLE1BQU0sRUFBRSxnQkFBZ0IsRUFBRSxHQUFHLE1BQU0sQ0FBQztJQUNwQyxJQUFJLEdBQThDLENBQUM7SUFFbkQsSUFDRSxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxRQUFRLENBQ3pELGdCQUFnQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQy9CO1FBQ0QsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQUMsUUFBUSxDQUN6RCxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUNoQztRQUNELGdCQUFnQixDQUFDLFFBQVEsS0FBSyxHQUFHLEVBQ2pDLENBQUM7UUFDRCxzRUFBc0U7UUFDdEUsSUFDRSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO1lBQ3BFLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsRUFDckUsQ0FBQztZQUNELEdBQUcsR0FBRztnQkFDSixJQUFJLEVBQUUsUUFBUSxDQUFDLFFBQVE7Z0JBQ3ZCLFNBQVMsRUFBRTtvQkFDVCxnQkFBZ0IsQ0FBQyxJQUFJO29CQUNyQixnQkFBZ0IsQ0FBQyxLQUFLO29CQUN0Qjt3QkFDRSxJQUFJLEVBQUUsU0FBUzt3QkFDZixLQUFLLEVBQUUsU0FBUzt3QkFDaEIsR0FBRyxFQUFFLFdBQVc7d0JBQ2hCLFFBQVEsRUFBRSxRQUFRO3FCQUNuQjtpQkFDRjtnQkFDRCxNQUFNLEVBQUU7b0JBQ04sSUFBSSxFQUFFLFlBQVk7b0JBQ2xCLElBQUksRUFBRSxlQUFlO2lCQUN0QjtnQkFDRCxRQUFRLEVBQUUsZ0JBQWdCLENBQUMsT0FBTzthQUNiLENBQUM7UUFDMUIsQ0FBQztRQUNELHVEQUF1RDthQUNsRCxJQUNILENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7WUFDaEUsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxFQUNqRSxDQUFDO1lBQ0QsR0FBRyxHQUFHO2dCQUNKLElBQUksRUFBRSxRQUFRLENBQUMsUUFBUTtnQkFDdkIsU0FBUyxFQUFFO29CQUNULGdCQUFnQixDQUFDLElBQUk7b0JBQ3JCLGdCQUFnQixDQUFDLEtBQUs7b0JBQ3RCO3dCQUNFLElBQUksRUFBRSxTQUFTO3dCQUNmLEtBQUssRUFBRSxTQUFTO3dCQUNoQixHQUFHLEVBQUUsV0FBVzt3QkFDaEIsUUFBUSxFQUFFLFFBQVE7cUJBQ25CO2lCQUNGO2dCQUNELE1BQU0sRUFBRTtvQkFDTixJQUFJLEVBQUUsWUFBWTtvQkFDbEIsSUFBSSxFQUFFLGVBQWU7aUJBQ3RCO2dCQUNELFFBQVEsRUFBRSxnQkFBZ0IsQ0FBQyxPQUFPO2FBQ2IsQ0FBQztRQUMxQixDQUFDO1FBQ0Qsd0RBQXdEO1FBQ3hELHNCQUFzQjtRQUN0Qiw4Q0FBOEM7YUFDekMsSUFDSCxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQ3pELGdCQUFnQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQy9CO1lBQ0QsQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUN6RCxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUNoQztZQUNELGdCQUFnQixDQUFDLElBQUksQ0FBQyxRQUFRLElBQUksZ0JBQWdCLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFDakUsQ0FBQztZQUNELEdBQUcsR0FBRztnQkFDSixJQUFJLEVBQUUsUUFBUSxDQUFDLFVBQVU7Z0JBQ3pCLElBQUksRUFBRSxnQkFBZ0IsQ0FBQyxJQUFJO2dCQUMzQixLQUFLLEVBQUUsZ0JBQWdCLENBQUMsS0FBSztnQkFDN0IsUUFBUSxFQUFFLEdBQUc7Z0JBQ2IsUUFBUSxFQUFFLGdCQUFnQixDQUFDLElBQUk7YUFDUixDQUFDO1FBQzVCLENBQUM7SUFDSCxDQUFDO1NBQU0sSUFDTCxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxRQUFRLENBQ3pELGdCQUFnQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQy9CO1FBQ0QsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQUMsUUFBUSxDQUN6RCxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUNoQztRQUNELGdCQUFnQixDQUFDLFFBQVEsS0FBSyxHQUFHLEVBQ2pDLENBQUM7UUFDRCwwRUFBMEU7UUFDMUUsSUFDRSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO1lBQ3BFLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsRUFDckUsQ0FBQztZQUNELE1BQU0sSUFBSSxHQUFHO2dCQUNYLElBQUksRUFBRSxRQUFRLENBQUMsUUFBUTtnQkFDdkIsU0FBUyxFQUFFO29CQUNULGdCQUFnQixDQUFDLElBQUk7b0JBQ3JCO3dCQUNFLElBQUksRUFBRSxTQUFTO3dCQUNmLEtBQUssRUFBRSxVQUFVO3dCQUNqQixHQUFHLEVBQUUsWUFBWTt3QkFDakIsUUFBUSxFQUFFLGdCQUFnQixDQUFDLFFBQVE7cUJBQ3BDO29CQUNEO3dCQUNFLElBQUksRUFBRSxTQUFTO3dCQUNmLEtBQUssRUFBRSxTQUFTO3dCQUNoQixHQUFHLEVBQUUsV0FBVzt3QkFDaEIsUUFBUSxFQUFFLFFBQVE7cUJBQ25CO2lCQUNGO2dCQUNELE1BQU0sRUFBRTtvQkFDTixJQUFJLEVBQUUsWUFBWTtvQkFDbEIsSUFBSSxFQUFFLGVBQWU7aUJBQ3RCO2dCQUNELFFBQVEsRUFBRSxnQkFBZ0IsQ0FBQyxPQUFPO2FBQ2IsQ0FBQztZQUN4QixNQUFNLEtBQUssR0FBRztnQkFDWixJQUFJLEVBQUUsUUFBUSxDQUFDLFFBQVE7Z0JBQ3ZCLFNBQVMsRUFBRTtvQkFDVCxnQkFBZ0IsQ0FBQyxLQUFLO29CQUN0Qjt3QkFDRSxJQUFJLEVBQUUsU0FBUzt3QkFDZixLQUFLLEVBQUUsVUFBVTt3QkFDakIsR0FBRyxFQUFFLFlBQVk7d0JBQ2pCLFFBQVEsRUFBRSxnQkFBZ0IsQ0FBQyxRQUFRO3FCQUNwQztvQkFDRDt3QkFDRSxJQUFJLEVBQUUsU0FBUzt3QkFDZixLQUFLLEVBQUUsU0FBUzt3QkFDaEIsR0FBRyxFQUFFLFdBQVc7d0JBQ2hCLFFBQVEsRUFBRSxRQUFRO3FCQUNuQjtpQkFDRjtnQkFDRCxNQUFNLEVBQUU7b0JBQ04sSUFBSSxFQUFFLFlBQVk7b0JBQ2xCLElBQUksRUFBRSxlQUFlO2lCQUN0QjtnQkFDRCxRQUFRLEVBQUUsZ0JBQWdCLENBQUMsT0FBTzthQUNiLENBQUM7WUFDeEIsT0FBTztnQkFDTCxJQUFJLEVBQUUsUUFBUSxDQUFDLFVBQVU7Z0JBQ3pCLElBQUk7Z0JBQ0osS0FBSztnQkFDTCxRQUFRLEVBQUUsR0FBRztnQkFDYixRQUFRLEVBQUUsZ0JBQWdCLENBQUMsT0FBTzthQUNYLENBQUM7UUFDNUIsQ0FBQztRQUNELHdEQUF3RDtRQUN4RCxzQkFBc0I7UUFDdEIsOENBQThDO2FBQ3pDLElBQ0gsQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUN6RCxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUMvQjtZQUNELENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FDekQsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FDaEM7WUFDRCxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxJQUFJLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQ2pFLENBQUM7WUFDRCxHQUFHLEdBQUc7Z0JBQ0osSUFBSSxFQUFFLFFBQVEsQ0FBQyxVQUFVO2dCQUN6QixJQUFJLEVBQUUsZ0JBQWdCLENBQUMsSUFBSTtnQkFDM0IsS0FBSyxFQUFFLGdCQUFnQixDQUFDLEtBQUs7Z0JBQzdCLFFBQVEsRUFBRSxHQUFHO2dCQUNiLFFBQVEsRUFBRSxnQkFBZ0IsQ0FBQyxJQUFJO2FBQ1IsQ0FBQztRQUM1QixDQUFDO0lBQ0gsQ0FBQztJQUNELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQUNELFNBQWUsMEJBQTBCLENBQ3ZDLFVBQXNCLEVBQ3RCLFVBQTZCLEVBQzdCLE9BQXFCLEVBQ3JCLE9BQTRFOztRQUU1RSw2QkFBNkI7UUFDN0IsTUFBTSxZQUFZLEdBQUcsTUFBTSxPQUFPLENBQUMsTUFBTSxDQUFDLENBQU8sVUFBVSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ2hFLE1BQU0sR0FBRyxHQUFHLE1BQU0sVUFBVSxDQUFDO1lBQzdCLElBQUksQ0FBQyxDQUFDLEVBQUUsS0FBSyxVQUFVLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUN6RCxNQUFNLFVBQVUsR0FBRztvQkFDakIsR0FBRyxJQUFJLEdBQUcsQ0FDUixDQUNHLENBQUMsQ0FBQyxVQUEwQixDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsSUFBSSxFQUFFLENBQ3JFLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FDakIsT0FBTyxDQUFDLElBQUksQ0FDVixDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsS0FBSyxLQUFLLElBQUksR0FBRyxDQUFDLElBQUksS0FBSyxPQUFPLENBQUMsT0FBTyxDQUMxRCxDQUNGLENBQ0Y7aUJBQ0YsQ0FBQztnQkFDRixJQUFJLFVBQVUsQ0FBQyxNQUFNO29CQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDO1lBQzFELENBQUM7aUJBQU0sSUFDTCxDQUFDLENBQUMsSUFBSSxLQUFLLE9BQU8sQ0FBQyxNQUFNO2dCQUN6QixDQUFDLENBQUMsSUFBSSxLQUFLLE9BQU8sQ0FBQyxtQkFBbUIsRUFDdEMsQ0FBQztnQkFDRCxNQUFNLFVBQVUsR0FBRyxNQUFNLHlCQUF5QixDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUN0RCxJQUFJLFVBQVUsYUFBVixVQUFVLHVCQUFWLFVBQVUsQ0FBRSxNQUFNO29CQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDO1lBQzNELENBQUM7WUFDRCxPQUFPLEdBQUcsQ0FBQztRQUNiLENBQUMsQ0FBQSxFQUFFLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUV4QixTQUFlLG9CQUFvQixDQUFDLEdBQWUsRUFBRSxPQUFxQjs7Z0JBQ3hFLE1BQU0sVUFBVSxHQUFHLEVBQUUsQ0FBQztnQkFFdEIsSUFBSSxVQUFVLENBQUMsV0FBVyxLQUFLLEdBQUcsQ0FBQyxXQUFXLEVBQUUsQ0FBQztvQkFDL0MsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztnQkFDbEIsQ0FBQztnQkFFRCwyREFBMkQ7Z0JBQzNELE1BQU0saUJBQWlCLEdBQ3BCLEdBQUcsQ0FBQyxVQUEwQixDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsSUFBSSxFQUFFLENBQUM7Z0JBRXpFLEtBQUssTUFBTSxRQUFRLElBQUksaUJBQWlCLEVBQUUsQ0FBQztvQkFDekMsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxRQUFRLENBQUMsQ0FBQztvQkFDdEQsSUFBSSxNQUFNLENBQUMsSUFBSSxLQUFLLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQzt3QkFDcEMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxvQkFBb0IsQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUNwRSxDQUFDO3lCQUFNLElBQ0wsTUFBTSxDQUFDLElBQUksS0FBSyxPQUFPLENBQUMsTUFBTTt3QkFDOUIsTUFBTSxDQUFDLElBQUksS0FBSyxPQUFPLENBQUMsbUJBQW1CLEVBQzNDLENBQUM7d0JBQ0QsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSx5QkFBeUIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ2hFLENBQUM7Z0JBQ0gsQ0FBQztnQkFDRCxPQUFPLFVBQVUsQ0FBQztZQUNwQixDQUFDO1NBQUE7UUFFRCxpREFBaUQ7UUFDakQsU0FBZSx5QkFBeUIsQ0FDdEMsZUFFQzs7Z0JBRUQsTUFBTSxVQUFVLEdBQUcsRUFBRSxDQUFDO2dCQUV0QixJQUFJLFVBQXNCLENBQUM7Z0JBQzNCLElBQUksY0FBK0MsQ0FBQztnQkFFcEQsSUFBSSxlQUFlLENBQUMsSUFBSSxLQUFLLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQztvQkFDNUMsTUFBTSxhQUFhLEdBQUksZUFBZSxDQUFDLFVBQXlCO3lCQUM3RCxxQkFBcUIsQ0FBQztvQkFDekIsTUFBTSxXQUFXLEdBQUksZUFBZSxDQUFDLFVBQXlCO3lCQUMzRCxtQkFBbUIsQ0FBQztvQkFDdkIsVUFBVSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssYUFBYSxDQUFDLENBQUM7b0JBQ3pELGNBQWMsR0FBRyxDQUFDLE1BQWtCLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEtBQUssV0FBVyxDQUFDO2dCQUNyRSxDQUFDO3FCQUFNLElBQUksZUFBZSxDQUFDLElBQUksS0FBSyxPQUFPLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztvQkFDaEUsVUFBVSxHQUFHLGVBQWUsQ0FBQztvQkFDN0IsY0FBYyxHQUFHLENBQUMsTUFBa0IsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7Z0JBQ3ZELENBQUM7Z0JBRUQsSUFBSSxVQUFVLEVBQUUsQ0FBQztvQkFDZixNQUFNLGdCQUFnQixHQUFHLE1BQU0sT0FBTyxDQUNuQyxVQUFVLENBQUMsVUFBc0MsQ0FBQyxtQkFBbUIsQ0FDdkUsQ0FBQztvQkFDRixNQUFNLFlBQVksR0FBRyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO29CQUVuRSxJQUFJLFlBQVksRUFBRSxDQUFDO3dCQUNqQixJQUFJLFlBQVksQ0FBQyxJQUFJLEtBQUssT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDOzRCQUMxQyxVQUFVLENBQUMsSUFBSSxDQUNiLEdBQUcsQ0FBQyxNQUFNLG9CQUFvQixDQUM1QixZQUFZLEVBQ1osZ0JBQWdCLENBQUMsT0FBTyxDQUN6QixDQUFDLENBQ0gsQ0FBQzt3QkFDSixDQUFDOzZCQUFNLElBQ0wsWUFBWSxDQUFDLElBQUksS0FBSyxPQUFPLENBQUMsTUFBTTs0QkFDcEMsWUFBWSxDQUFDLElBQUksS0FBSyxPQUFPLENBQUMsbUJBQW1CLEVBQ2pELENBQUM7NEJBQ0QsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSx5QkFBeUIsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQ3RFLENBQUM7b0JBQ0gsQ0FBQztnQkFDSCxDQUFDO2dCQUNELE9BQU8sQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7WUFDbEMsQ0FBQztTQUFBO1FBRUQseUVBQXlFO1FBQ3pFLE1BQU0sZ0JBQWdCLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FDbkMsQ0FBQyxDQUFhLEVBQUUsRUFBRSxDQUNoQixDQUFDLENBQUMsS0FBSyxLQUFNLFVBQTZCLENBQUMsSUFBSTtZQUMvQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLG1CQUFtQixFQUFFLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxRQUFRLENBQ3JFLENBQUMsQ0FBQyxJQUFlLENBQ2xCLENBQ0osQ0FBQztRQUVGLElBQUksZ0JBQWdCLEtBQUksVUFBVSxhQUFWLFVBQVUsdUJBQVYsVUFBVSxDQUFFLEVBQUUsQ0FBQSxFQUFFLENBQUM7WUFDdkMsWUFBWSxDQUFDLElBQUksQ0FBQztnQkFDaEIsQ0FBQyxVQUFVLGFBQVYsVUFBVSx1QkFBVixVQUFVLENBQUUsRUFBWSxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUM7YUFDbEQsQ0FBQyxDQUFDO1FBQ0wsQ0FBQztRQUNELE1BQU0sUUFBUSxHQUFHLFlBQVksQ0FBQyxNQUFNLENBQUM7UUFDckMsSUFBSSxRQUFRLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFDakIsMENBQTBDO1lBQzFDLE1BQU0sR0FBRyxHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7WUFDdEIsTUFBTSxTQUFTLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQztZQUM1QixpQ0FBaUM7WUFFakMsS0FBSyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQztnQkFDbEQsTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDOUIsTUFBTSxVQUFVLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUMxQixTQUFTLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO2dCQUM1QyxLQUFLLE1BQU0sU0FBUyxJQUFJLFVBQVUsRUFBRSxDQUFDO29CQUNuQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO29CQUN6RCxTQUFTLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQ2hFLENBQUM7WUFDSCxDQUFDO1lBQ0QsTUFBTSxLQUFLLEdBQWEsRUFBRSxDQUFDO1lBQzNCLHdFQUF3RTtZQUN4RSxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsUUFBUSxFQUFFLEdBQUcsRUFBRSxFQUFFO2dCQUNsQyxJQUFJLFFBQVEsS0FBSyxDQUFDLEVBQUUsQ0FBQztvQkFDbkIseURBQXlEO29CQUN6RCxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUNsQixDQUFDO1lBQ0gsQ0FBQyxDQUFDLENBQUM7WUFDSCxpQ0FBaUM7WUFDakMsSUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDO1lBQ2hCLE1BQU07WUFDTixPQUFPLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7Z0JBQzFCLGlDQUFpQztnQkFDakMsTUFBTSxHQUFHLEdBQUcsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO2dCQUMxQixxREFBcUQ7Z0JBQ3JELE1BQU0sVUFBVSxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQztnQkFDN0MsSUFBSSxVQUFVLENBQUMsSUFBSSxHQUFHLENBQUMsRUFBRSxDQUFDO29CQUN4QixPQUFPLElBQUksQ0FBQyxDQUFDO2dCQUNmLENBQUM7Z0JBQ0Qsa0NBQWtDO2dCQUNsQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsU0FBaUIsRUFBRSxFQUFFO29CQUN2Qyw0Q0FBNEM7b0JBQzVDLFNBQVMsQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7b0JBQ3ZELHlCQUF5QjtvQkFDekIsSUFBSSxTQUFTLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO3dCQUNuQyw2Q0FBNkM7d0JBQzdDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7b0JBQ3hCLENBQUM7Z0JBQ0gsQ0FBQyxDQUFDLENBQUM7WUFDTCxDQUFDO1lBQ0QsNkNBQTZDO1lBQzdDLElBQUksUUFBUSxLQUFLLE9BQU8sRUFBRSxDQUFDO2dCQUN6QixNQUFNLElBQUksWUFBWSxDQUNwQixnQkFBZ0IsQ0FBQyxrQkFBa0IsRUFDbkM7b0JBQ0UsR0FBRyxFQUFFLHVDQUF1QztpQkFDN0MsRUFDRCw2QkFBNkIsQ0FDOUIsQ0FBQztZQUNKLENBQUM7UUFDSCxDQUFDO0lBQ0gsQ0FBQztDQUFBO0FBRUQsTUFBTSxVQUFnQixxQ0FBcUM7eURBQUMsRUFDMUQsT0FBTyxFQUNQLE1BQU0sRUFDTixPQUFPLEVBQ1AsYUFBYSxFQUNiLE9BQU8sRUFDUCxhQUFhLEdBUWQ7UUFDQyxNQUFNLEtBQUssR0FDVCxPQUFPLGFBQWEsS0FBSyxRQUFRO1lBQy9CLENBQUMsQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLEVBQUUsTUFBTSxFQUFFLGFBQWEsRUFBRSxDQUFDO1lBQ2hELENBQUMsQ0FBQyxhQUFhLENBQUM7UUFFcEIsTUFBTSxnQkFBZ0IsR0FBRyxFQUFFLENBQUM7UUFDNUIsTUFBTSxhQUFhLEdBQUcsRUFBRSxDQUFDO1FBRXpCLEtBQUssTUFBTSxHQUFHLElBQUksT0FBTyxFQUFFLENBQUM7WUFDMUIsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUNsQyxhQUFhLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQztRQUM5QixDQUFDO1FBRUQsTUFBTSxrQkFBa0IsR0FBRyxDQUN6QixVQUE2QixFQUNELEVBQUU7O1lBQzlCLE1BQU0sR0FBRyxxQkFBMkIsVUFBVSxDQUFFLENBQUM7WUFFakQsSUFBSSxVQUFVLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQztnQkFDMUMsTUFBTSxVQUFVLEdBQ2QsVUFBVSxDQUFDLE1BQ1osQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7Z0JBQ3JCLHlCQUF5QjtnQkFDekIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDO29CQUMxQixNQUFNLElBQUksWUFBWSxDQUNwQixnQkFBZ0IsQ0FBQyxxQkFBcUIsRUFDdEM7d0JBQ0UsVUFBVTt3QkFDVixRQUFRLEVBQ0wsVUFBa0IsQ0FBQyxVQUFVLElBQUksQ0FBQzs0QkFDakMsQ0FBQyxDQUFDO2dDQUNFLEtBQUssRUFBRyxVQUFrQixDQUFDLFVBQVU7Z0NBQ3JDLE1BQU0sRUFBRyxVQUFrQixDQUFDLFVBQVU7NkJBQ3ZDOzRCQUNILENBQUMsQ0FBQyxTQUFTO3FCQUNoQixFQUNELFlBQVksVUFBVSxtQkFBbUIsQ0FDMUMsQ0FBQztnQkFDSixDQUFDO3FCQUFNLElBQUksS0FBSyxhQUFMLEtBQUssdUJBQUwsS0FBSyxDQUFFLG9CQUFvQixHQUFHLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDO29CQUM5RCxNQUFNLElBQUksWUFBWSxDQUNwQixnQkFBZ0IsQ0FBQyxxQkFBcUIsRUFDdEM7d0JBQ0UsVUFBVTt3QkFDVixRQUFRLEVBQ0wsVUFBa0IsQ0FBQyxVQUFVLElBQUksQ0FBQzs0QkFDakMsQ0FBQyxDQUFDO2dDQUNFLEtBQUssRUFBRyxVQUFrQixDQUFDLFVBQVU7Z0NBQ3JDLE1BQU0sRUFBRyxVQUFrQixDQUFDLFVBQVU7NkJBQ3ZDOzRCQUNILENBQUMsQ0FBQyxTQUFTO3FCQUNoQixFQUNELFlBQVksVUFBVSxtQ0FBbUMsQ0FDMUQsQ0FBQztnQkFDSixDQUFDO2dCQUVELHFCQUFxQjtnQkFDckIsTUFBTSxVQUFVLEdBQ2QsUUFBUSxDQUFDLFVBQVUsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQyxVQUFVLENBQUM7Z0JBQzFELElBQUksVUFBVSxJQUFJLFVBQVUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztvQkFDbEMsSUFDRSxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxTQUFTO3dCQUNqQyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxVQUFVLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFDbkQsQ0FBQzt3QkFDRCxNQUFNLElBQUksWUFBWSxDQUNwQixnQkFBZ0IsQ0FBQyxXQUFXLEVBQzVCOzRCQUNFLEdBQUcsRUFBRSxzQ0FBc0M7NEJBQzNDLGlCQUFpQixFQUFFLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRzs0QkFDdEMsVUFBVTs0QkFDVixRQUFRLEVBQ0wsVUFBa0IsQ0FBQyxVQUFVLElBQUksQ0FBQztnQ0FDakMsQ0FBQyxDQUFDO29DQUNFLEtBQUssRUFBRyxVQUFrQixDQUFDLFVBQVU7b0NBQ3JDLE1BQU0sRUFBRyxVQUFrQixDQUFDLFVBQVU7aUNBQ3ZDO2dDQUNILENBQUMsQ0FBQyxTQUFTO3lCQUNoQixFQUNELDRCQUE0QixDQUM3QixDQUFDO29CQUNKLENBQUM7eUJBQU0sSUFDTCxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxTQUFTO3dCQUNqQyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxVQUFVLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFDakQsQ0FBQzt3QkFDRCxNQUFNLElBQUksWUFBWSxDQUNwQixnQkFBZ0IsQ0FBQyxPQUFPLEVBQ3hCOzRCQUNFLEdBQUcsRUFBRSx5Q0FBeUM7NEJBQzlDLG9CQUFvQixFQUFFLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRzs0QkFDekMsVUFBVTs0QkFDVixRQUFRLEVBQ0wsVUFBa0IsQ0FBQyxVQUFVLElBQUksQ0FBQztnQ0FDakMsQ0FBQyxDQUFDO29DQUNFLEtBQUssRUFBRyxVQUFrQixDQUFDLFVBQVU7b0NBQ3JDLE1BQU0sRUFBRyxVQUFrQixDQUFDLFVBQVU7aUNBQ3ZDO2dDQUNILENBQUMsQ0FBQyxTQUFTO3lCQUNoQixFQUNELDRCQUE0QixDQUM3QixDQUFDO29CQUNKLENBQUM7eUJBQU0sSUFDTCxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxTQUFTO3dCQUNqQyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxVQUFVLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFDakQsQ0FBQzt3QkFDRCxNQUFNLElBQUksWUFBWSxDQUNwQixnQkFBZ0IsQ0FBQyxXQUFXLEVBQzVCOzRCQUNFLEdBQUcsRUFBRSx5Q0FBeUM7NEJBQzlDLG9CQUFvQixFQUFFLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRzs0QkFDekMsVUFBVTs0QkFDVixRQUFRLEVBQ0wsVUFBa0IsQ0FBQyxVQUFVLElBQUksQ0FBQztnQ0FDakMsQ0FBQyxDQUFDO29DQUNFLEtBQUssRUFBRyxVQUFrQixDQUFDLFVBQVU7b0NBQ3JDLE1BQU0sRUFBRyxVQUFrQixDQUFDLFVBQVU7aUNBQ3ZDO2dDQUNILENBQUMsQ0FBQyxTQUFTO3lCQUNoQixFQUNELDJCQUEyQixDQUM1QixDQUFDO29CQUNKLENBQUM7Z0JBQ0gsQ0FBQztnQkFDRCw2QkFBNkI7Z0JBQzdCLE1BQU0sY0FBYyxHQUFHLENBQUUsR0FBMEIsQ0FBQyxTQUFTO29CQUMzRCxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQ2YsVUFBVSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTt3QkFDL0IsT0FBTyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFDakMsQ0FBQyxDQUFDLENBQ0gsQ0FBQyxDQUFDO2dCQUVMLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFNLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFFNUQsNkNBQTZDO2dCQUM3QyxJQUFJLE1BQUEsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFVBQVUsMENBQUUsTUFBTSxFQUFFLENBQUM7b0JBQzVDLE1BQUEsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFVBQVUsMENBQUUsTUFBTSxDQUFDLFFBQVEsRUFBRSxVQUFVLENBQUMsQ0FBQztnQkFDaEUsQ0FBQztnQkFDRCxpREFBaUQ7cUJBQzVDLElBQUksTUFBQSxNQUFBLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQyxVQUFVLDBDQUFFLElBQUksMENBQUUsSUFBSSxFQUFFLENBQUM7b0JBQ3JELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxjQUFjLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7d0JBQy9DLE1BQU0sS0FBSyxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFFaEMsVUFBVTt3QkFDVixNQUFNLGVBQWUsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUNuQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQzFDOzRCQUNDLENBQUMsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDOzRCQUM5QyxDQUFDLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO3dCQUU5QyxJQUNFLEtBQUssQ0FBQyxRQUFRLEtBQUssZUFBZTs0QkFDbEMsS0FBSyxDQUFDLFFBQVEsS0FBSyxnQkFBZ0IsQ0FBQyxJQUFJOzRCQUN4QyxLQUFLLENBQUMsUUFBUSxLQUFLLGdCQUFnQixDQUFDLE9BQU87NEJBQzNDLGVBQWUsS0FBSyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQzNDLENBQUM7NEJBQ0QsSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyxVQUFVLEVBQUUsQ0FBQztnQ0FDdkMsTUFBTSxJQUFJLEdBQ1IsQ0FBQSxNQUFBLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxJQUFJLENBQ1gsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsS0FBSyxLQUFLLEtBQUssQ0FBQyxJQUFJLENBQ3JELDBDQUFFLEtBQUssS0FBSSxLQUFLLENBQUMsSUFBSSxDQUFDO2dDQUV6QixNQUFNLElBQUksWUFBWSxDQUNwQixnQkFBZ0IsQ0FBQyxXQUFXLEVBQzVCO29DQUNFLEdBQUcsRUFBRSw0Q0FBNEM7b0NBQ2pELFVBQVUsRUFBRSxJQUFJO29DQUNoQixVQUFVLEVBQUUsS0FBSyxDQUFDLFFBQVE7b0NBQzFCLFlBQVksRUFBRSxlQUFlO2lDQUM5QixFQUNELFNBQVMsSUFBSSxTQUFTLEtBQUssQ0FBQyxRQUFRLHNCQUFzQixlQUFlLG1CQUFtQixDQUM3RixDQUFDOzRCQUNKLENBQUM7aUNBQU0sQ0FBQztnQ0FDTixJQUFJLEdBQUcsR0FBRyxFQUFFLENBQUM7Z0NBQ2IsTUFBTSxRQUFRLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQ0FDdkIsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDO2dDQUVkLElBQUksZUFBZSxLQUFLLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxDQUFDO29DQUNqRCxHQUFHLEdBQUcsNEJBQTRCLENBQUM7b0NBQ25DLElBQUksR0FBRyxTQUFTLENBQUM7Z0NBQ25CLENBQUM7cUNBQU0sSUFBSSxlQUFlLEtBQUssZ0JBQWdCLENBQUMsT0FBTyxFQUFFLENBQUM7b0NBQ3hELEdBQUcsR0FBRyw0QkFBNEIsQ0FBQztvQ0FDbkMsSUFBSSxHQUFHLFNBQVMsQ0FBQztnQ0FDbkIsQ0FBQztxQ0FBTSxJQUFJLGVBQWUsS0FBSyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsQ0FBQztvQ0FDckQsR0FBRyxHQUFHLDRCQUE0QixDQUFDO29DQUNuQyxJQUFJLEdBQUcsTUFBTSxDQUFDO2dDQUNoQixDQUFDO2dDQUVELE1BQU0sSUFBSSxZQUFZLENBQ3BCLGdCQUFnQixDQUFDLFdBQVcsRUFDNUI7b0NBQ0UsSUFBSTtvQ0FDSixHQUFHO29DQUNILFFBQVE7b0NBQ1IsVUFBVTtpQ0FDWCxFQUNELEdBQUcsVUFBVSxhQUFWLFVBQVUsdUJBQVYsVUFBVSxDQUFFLFdBQVcsRUFBRSxlQUMxQixJQUFJLElBQUksZUFDVixnQkFBZ0IsUUFBUSxFQUFFLENBQzNCLENBQUM7NEJBQ0osQ0FBQzt3QkFDSCxDQUFDO3dCQUVELGdGQUFnRjt3QkFDaEYsSUFDRSxlQUFlLEtBQUssZ0JBQWdCLENBQUMsTUFBTTs0QkFDM0MsZUFBZSxLQUFLLEtBQUssQ0FBQyxRQUFRLEVBQ2xDLENBQUM7NEJBQ0QsS0FBSyxDQUFDLElBQUksR0FBRyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUM7d0JBQ3ZDLENBQUM7b0JBQ0gsQ0FBQztnQkFDSCxDQUFDO2dCQUVELElBQUksT0FBTyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUMsVUFBVSxLQUFLLFVBQVUsRUFBRSxDQUFDO29CQUMxRCxHQUFHLENBQUMsUUFBUSxHQUFHLE1BQUMsTUFBQSxRQUFRLENBQUMsVUFBVSxDQUFDLEVBQUMsVUFBa0IsbURBQ3JELFFBQVEsQ0FDVyxDQUFDO2dCQUN4QixDQUFDO3FCQUFNLElBQUksUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFVBQVUsRUFBRSxDQUFDO29CQUMzQyxHQUFHLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQyxVQUE4QixDQUFDO2dCQUNyRSxDQUFDO1lBQ0gsQ0FBQztpQkFBTSxJQUFJLFVBQVUsQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDLFVBQVUsRUFBRSxDQUFDO2dCQUNuRCxNQUFNLGNBQWMsR0FBSSxVQUE2QixDQUFDLElBQUksQ0FBQztnQkFDM0QsTUFBTSxHQUFHLEdBQUcsQ0FBQyxhQUFhLENBQUMsY0FBYyxDQUFDO29CQUN4QyxnQkFBZ0IsQ0FBQyxjQUFjLENBQUMsQ0FBd0IsQ0FBQztnQkFFM0QsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO29CQUNULElBQUksUUFBUSxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUM7d0JBQzdCLE1BQU0sSUFBSSxZQUFZLENBQ3BCLGdCQUFnQixDQUFDLGNBQWMsRUFDL0I7NEJBQ0UsR0FBRyxFQUFFLHVDQUF1Qzs0QkFDNUMsVUFBVSxFQUFFLGNBQWM7NEJBQzFCLFFBQVEsRUFDTCxVQUFrQixDQUFDLFVBQVUsSUFBSSxDQUFDO2dDQUNqQyxDQUFDLENBQUM7b0NBQ0UsS0FBSyxFQUFHLFVBQWtCLENBQUMsUUFBUTtvQ0FDbkMsTUFBTSxFQUFFLENBQUM7aUNBQ1Y7Z0NBQ0gsQ0FBQyxDQUFDLFNBQVM7eUJBQ2hCLEVBQ0QsNENBQTRDLElBQUksQ0FBQyxTQUFTLENBQ3hELGNBQWMsQ0FDZixHQUFHLENBQ0wsQ0FBQztvQkFDSixDQUFDO29CQUNELE1BQU0sSUFBSSxZQUFZLENBQ3BCLGdCQUFnQixDQUFDLGNBQWMsRUFDL0I7d0JBQ0UsR0FBRyxFQUFFLGdDQUFnQzt3QkFDckMsVUFBVSxFQUFFLGNBQWM7d0JBQzFCLFFBQVEsRUFDTCxVQUFrQixDQUFDLFVBQVUsSUFBSSxDQUFDOzRCQUNqQyxDQUFDLENBQUM7Z0NBQ0UsS0FBSyxFQUFHLFVBQWtCLENBQUMsVUFBVTtnQ0FDckMsTUFBTSxFQUFHLFVBQWtCLENBQUMsVUFBVTs2QkFDdkM7NEJBQ0gsQ0FBQyxDQUFDLFNBQVM7cUJBQ2hCLEVBQ0QsMEJBQTBCLElBQUksQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLGFBQWEsQ0FDdEUsQ0FBQztnQkFDSixDQUFDO2dCQUVBLEdBQXNCLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFLENBQUM7Z0JBRXRDLElBQUksQ0FBQSxHQUFHLGFBQUgsR0FBRyx1QkFBSCxHQUFHLENBQUUsSUFBSSxNQUFLLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQztvQkFDbEMsSUFBSSxNQUFNLEVBQUUsQ0FBQzt3QkFDWCxnR0FBZ0c7d0JBQ2hHLE1BQU0sMEJBQTBCLENBQzlCLE1BQU0sRUFDTixVQUFVLEVBQ1YsT0FBTyxFQUNQLE9BQU8sQ0FDUixDQUFDO29CQUNKLENBQUM7b0JBQ0QsTUFBTSxVQUFVLEdBQ2IsR0FBRyxDQUFDLFVBQTBCLENBQUMsV0FBVzt3QkFDM0MsQ0FBQyxNQUFNLHFDQUFxQzt3QkFDMUMsZ0VBQWdFO3dCQUNoRSx5REFBeUQ7d0JBQ3pEOzRCQUNFLE9BQU8sRUFBRSxHQUFHLENBQUMsVUFBVSxDQUFDLE9BQU87aUNBQzVCLFVBQVUsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDO2lDQUNyQixVQUFVLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQzs0QkFDeEIsT0FBTzs0QkFDUCxhQUFhOzRCQUNiLE9BQU87eUJBQ1IsQ0FDRixDQUFDLENBQUM7b0JBRUwsR0FBRyxDQUFDLFFBQVEsR0FBSSxVQUFnQyxhQUFoQyxVQUFVLHVCQUFWLFVBQVUsQ0FBd0IsUUFBUSxDQUFDO2dCQUM3RCxDQUFDO3FCQUFNLENBQUM7b0JBQ04sSUFDRSxDQUFBLEdBQUcsYUFBSCxHQUFHLHVCQUFILEdBQUcsQ0FBRSxJQUFJLE1BQUssT0FBTyxDQUFDLE1BQU07d0JBQzVCLENBQUEsR0FBRyxhQUFILEdBQUcsdUJBQUgsR0FBRyxDQUFFLElBQUksTUFBSyxPQUFPLENBQUMsbUJBQW1CLEVBQ3pDLENBQUM7d0JBQ0QsZ0dBQWdHO3dCQUNoRyxJQUFJLE1BQU0sRUFBRSxDQUFDOzRCQUNYLE1BQU0sMEJBQTBCLENBQzlCLE1BQU0sRUFDTixVQUFVLEVBQ1YsT0FBTyxFQUNQLE9BQU8sQ0FDUixDQUFDO3dCQUNKLENBQUM7b0JBQ0gsQ0FBQztvQkFFRCw4QkFBOEI7b0JBQzlCLE1BQU0sQ0FBQyxNQUFNLENBQ1gsR0FBRyxFQUNILE1BQU0sMkJBQTJCLENBQUM7d0JBQ2hDLEdBQUc7d0JBQ0gsT0FBTzt3QkFDUCxPQUFPO3dCQUNQLGFBQWE7cUJBQ2QsQ0FBQyxDQUNILENBQUM7Z0JBQ0osQ0FBQztZQUNILENBQUM7aUJBQU0sSUFBSSxVQUFVLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQkFDaEQsSUFBSSxPQUFPLFVBQVUsQ0FBQyxLQUFLLEtBQUssUUFBUSxFQUFFLENBQUM7b0JBQ3pDLEdBQUcsQ0FBQyxRQUFRLEdBQUcsZ0JBQWdCLENBQUMsT0FBTyxDQUFDO2dCQUMxQyxDQUFDO3FCQUFNLElBQUksT0FBTyxVQUFVLENBQUMsS0FBSyxLQUFLLFFBQVEsRUFBRSxDQUFDO29CQUNoRCxHQUFHLENBQUMsUUFBUSxHQUFHLGdCQUFnQixDQUFDLE1BQU0sQ0FBQztnQkFDekMsQ0FBQztxQkFBTSxJQUFJLE9BQU8sVUFBVSxDQUFDLEtBQUssS0FBSyxTQUFTLEVBQUUsQ0FBQztvQkFDakQsR0FBRyxDQUFDLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUM7Z0JBQzFDLENBQUM7cUJBQU0sQ0FBQztvQkFDTixHQUFHLENBQUMsUUFBUSxHQUFHLGdCQUFnQixDQUFDLE1BQU0sQ0FBQztnQkFDekMsQ0FBQztZQUNILENBQUM7aUJBQU0sSUFBSSxVQUFVLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBQztnQkFDbEQsMEJBQTBCO2dCQUMxQixJQUNFLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUM7b0JBQ25DLFVBQVUsQ0FBQyxRQUFRLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyxPQUFPO29CQUM3QyxPQUFPLFVBQVUsQ0FBQyxRQUFRLENBQUMsS0FBSyxLQUFLLFFBQVEsRUFDN0MsQ0FBQztvQkFDRCxHQUFHLENBQUMsUUFBUSxHQUFHLGdCQUFnQixDQUFDLE9BQU8sQ0FBQztnQkFDMUMsQ0FBQztxQkFBTSxDQUFDO29CQUNOLE1BQU0sSUFBSSxZQUFZLENBQ3BCLGdCQUFnQixDQUFDLGFBQWEsRUFDOUIsRUFBRSxFQUNGLHFCQUFxQixVQUFVLENBQUMsUUFBUSxvQkFBb0IsQ0FDN0QsQ0FBQztnQkFDSixDQUFDO1lBQ0gsQ0FBQztpQkFBTSxJQUFJLFVBQVUsQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDLFVBQVUsRUFBRSxDQUFDO2dCQUNsRCxHQUE0QixDQUFDLElBQUksR0FBRyxNQUFNLGtCQUFrQixDQUMzRCxVQUFVLENBQUMsSUFBSSxDQUNoQixDQUFDO2dCQUNELEdBQTRCLENBQUMsS0FBSyxHQUFHLE1BQU0sa0JBQWtCLENBQzVELFVBQVUsQ0FBQyxLQUFLLENBQ2pCLENBQUM7Z0JBRUYsTUFBTSxxQkFBcUIsR0FBRyxvQ0FBb0MsQ0FBQztvQkFDakUsZ0JBQWdCLEVBQUUsR0FBVTtpQkFDN0IsQ0FBQyxDQUFDO2dCQUNILElBQUkscUJBQXFCLEVBQUUsQ0FBQztvQkFDMUIsTUFBTSxDQUFDLE1BQU0sQ0FDWCxHQUFHLEVBQ0gsb0NBQW9DLENBQUMsRUFBRSxnQkFBZ0IsRUFBRSxHQUFVLEVBQUUsQ0FBQyxDQUN2RSxDQUFDO29CQUNGLElBQUksR0FBRyxDQUFDLElBQUksS0FBSyxRQUFRLENBQUMsVUFBVSxFQUFFLENBQUM7d0JBQ3BDLEdBQVcsQ0FBQyxJQUFJLEdBQUcsU0FBUyxDQUFDO3dCQUM3QixHQUFXLENBQUMsS0FBSyxHQUFHLFNBQVMsQ0FBQzt3QkFDOUIsR0FBVyxDQUFDLFFBQVEsR0FBRyxTQUFTLENBQUM7b0JBQ3BDLENBQUM7Z0JBQ0gsQ0FBQztxQkFBTSxJQUNMLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxFQUNoRSxDQUFDO29CQUNELEdBQUcsQ0FBQyxRQUFRLEdBQUcsZ0JBQWdCLENBQUMsUUFBUSxDQUFDO2dCQUMzQyxDQUFDO3FCQUFNLElBQUksVUFBVSxDQUFDLFFBQVEsS0FBSyxHQUFHLEVBQUUsQ0FBQztvQkFDdkMsR0FBRyxDQUFDLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUM7b0JBQ3hDLHFGQUFxRjtvQkFDckYsc0JBQXNCO29CQUN0QixJQUNFO3dCQUNHLEdBQTRCLENBQUMsSUFBSTt3QkFDakMsR0FBNEIsQ0FBQyxLQUFLO3FCQUNwQyxDQUFDLElBQUksQ0FDSixDQUFDLENBQUMsRUFBRSxFQUFFLENBQ0osQ0FBQzt3QkFDQyxnQkFBZ0IsQ0FBQyxPQUFPO3dCQUN4QixnQkFBZ0IsQ0FBQyxPQUFPO3dCQUN4QixnQkFBZ0IsQ0FBQyxJQUFJO3dCQUNyQixnQkFBZ0IsQ0FBQyxPQUFPO3FCQUN6QixDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQ3pCLEVBQ0QsQ0FBQzt3QkFDRCxHQUFHLENBQUMsUUFBUSxHQUFHLGdCQUFnQixDQUFDLE1BQU0sQ0FBQztvQkFDekMsQ0FBQztnQkFDSCxDQUFDO3FCQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7b0JBQy9DLEdBQUcsQ0FBQyxRQUFRLEdBQUcsZ0JBQWdCLENBQUMsTUFBTSxDQUFDO2dCQUN6QyxDQUFDO3FCQUFNLENBQUM7b0JBQ04sR0FBRyxDQUFDLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUM7Z0JBQzFDLENBQUM7WUFDSCxDQUFDO2lCQUFNLElBQUksVUFBVSxDQUFDLElBQUksS0FBSyxRQUFRLENBQUMsVUFBVSxFQUFFLENBQUM7Z0JBQ25ELE1BQU0sSUFBSSxZQUFZLENBQ3BCLGdCQUFnQixDQUFDLGFBQWEsRUFDOUIsRUFBRSxFQUNGLG1DQUFtQyxDQUNwQyxDQUFDO1lBQ0osQ0FBQztpQkFBTSxJQUFJLFVBQVUsQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFDO2dCQUNsRCxNQUFNLElBQUksWUFBWSxDQUNwQixnQkFBZ0IsQ0FBQyxhQUFhLEVBQzlCLEVBQUUsRUFDRix3QkFBd0IsQ0FDekIsQ0FBQztZQUNKLENBQUM7aUJBQU0sSUFBSSxVQUFVLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQztnQkFDakQsTUFBTSxJQUFJLFlBQVksQ0FDcEIsZ0JBQWdCLENBQUMsYUFBYSxFQUM5QixFQUFFLEVBQ0YscUNBQXFDLENBQ3RDLENBQUM7WUFDSixDQUFDO1lBQ0QsT0FBTyxHQUFHLENBQUM7UUFDYixDQUFDLENBQUEsQ0FBQztRQUVGLElBQUksQ0FBQztZQUNILDJCQUEyQjtZQUMzQixJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUNyQyxJQUFJLGFBQWEsRUFBRSxDQUFDO2dCQUNsQixJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUN2QyxDQUFDO1lBQ0QsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3BDLHdDQUF3QztZQUN4QyxNQUFNLE1BQU0sR0FBRyxNQUFNLGtCQUFrQixDQUNyQyxhQUE2QyxDQUM5QyxDQUFDO1lBQ0YsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUFDLE9BQU8sRUFBRSxFQUFFLENBQUM7WUFDWixJQUFJLGFBQWEsRUFBRSxDQUFDO2dCQUNsQixrQkFBa0IsQ0FBQyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUM3QyxDQUFDO1lBQ0QsTUFBTSxFQUFFLENBQUM7UUFDWCxDQUFDO0lBQ0gsQ0FBQztDQUFBIn0=