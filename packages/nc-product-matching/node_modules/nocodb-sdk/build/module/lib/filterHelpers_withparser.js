import { QueryFilterParser } from '../lib/parser/queryFilter/query-filter-parser';
import UITypes from './UITypes';
import { InvalidFilterError } from './error/invalid-filter.error';
import { COMPARISON_SUB_OPS, IS_WITHIN_COMPARISON_SUB_OPS, } from './filterHelpers';
export { COMPARISON_OPS, COMPARISON_SUB_OPS, GROUPBY_COMPARISON_OPS, IS_WITHIN_COMPARISON_SUB_OPS, } from '../lib/parser/queryFilter/query-filter-lexer';
export function extractFilterFromXwhere(str, aliasColObjMap, throwErrorIfInvalid = false, errors = []) {
    if (!str) {
        return { filters: [] };
    }
    for (const columnName of Object.keys(aliasColObjMap)) {
        const column = aliasColObjMap[columnName];
        aliasColObjMap[column.id] = column;
    }
    return innerExtractFilterFromXwhere(str, aliasColObjMap, throwErrorIfInvalid, errors);
}
function innerExtractFilterFromXwhere(str, aliasColObjMap, throwErrorIfInvalid = false, errors = []) {
    if (!str) {
        return { filters: [] };
    } // if array treat it as `and` group
    else if (Array.isArray(str)) {
        // calling recursively for nested query
        const nestedFilters = [].concat(...str.map((s) => extractFilterFromXwhere(s, aliasColObjMap, throwErrorIfInvalid)));
        // extract and flatten filters
        const filters = nestedFilters.reduce((acc, { filters }) => {
            if (!filters)
                return acc;
            return [...acc, ...filters];
        }, []);
        // extract and flatten errors
        const collectedErrors = nestedFilters.reduce((acc, { errors }) => {
            if (!errors)
                return acc;
            return [...acc, ...errors];
        }, []);
        // If errors exist, return them
        if (collectedErrors.length > 0) {
            return { errors: collectedErrors };
        }
        // If there's only one filter, return it directly
        if (filters.length === 1) {
            return { filters: nestedFilters };
        }
        // Otherwise, wrap it in an AND group
        return {
            filters: [
                {
                    is_group: true,
                    logical_op: 'and',
                    children: filters,
                },
            ],
        };
    }
    else if (typeof str !== 'string' && throwErrorIfInvalid) {
        const message = 'Invalid filter format. Expected string or array of strings';
        if (throwErrorIfInvalid) {
            throw new InvalidFilterError({ message });
        }
        else {
            errors.push({ message });
            return { errors };
        }
    }
    const parseResult = QueryFilterParser.parse(str);
    if ((parseResult.lexErrors.length > 0 || parseResult.parseErrors.length > 0) &&
        throwErrorIfInvalid) {
        if (throwErrorIfInvalid)
            throw new InvalidFilterError({
                lexingError: parseResult.lexErrors,
                parsingError: parseResult.parseErrors,
            });
        else {
            errors.push({
                message: 'Invalid filter format',
            });
            return { errors };
        }
    }
    const filterSubType = parseResult.parsedCst;
    const { filter, errors: parseErrors } = mapFilterGroupSubType(filterSubType, aliasColObjMap, throwErrorIfInvalid);
    if ((parseErrors === null || parseErrors === void 0 ? void 0 : parseErrors.length) > 0) {
        return { errors: parseErrors };
    }
    return { filters: [filter] };
}
function mapFilterGroupSubType(filter, aliasColObjMap, throwErrorIfInvalid = false, errors = []) {
    const children = filter.children
        .map((k) => k.is_group
        ? mapFilterGroupSubType(k, aliasColObjMap, throwErrorIfInvalid, errors)
        : mapFilterClauseSubType(k, aliasColObjMap, throwErrorIfInvalid, errors))
        .filter((k) => k);
    if (children.length === 1) {
        return children[0];
    }
    else {
        return {
            filter: {
                is_group: filter.is_group,
                logical_op: filter.logical_op,
                children: children.map((k) => k.filter),
            },
        };
    }
}
function mapFilterClauseSubType(filter, aliasColObjMap, throwErrorIfInvalid = false, errors = []) {
    const aliasCol = aliasColObjMap[filter.field];
    if (!aliasCol) {
        if (throwErrorIfInvalid) {
            throw new InvalidFilterError({
                message: `Invalid filter field '${filter.field}' not found`,
            });
        }
        else {
            errors.push({
                message: `Invalid filter field '${filter.field}' not found`,
            });
            return { errors };
        }
        return {};
    }
    const result = {
        fk_column_id: aliasCol.id,
        is_group: false,
        logical_op: filter.logical_op,
        comparison_op: filter.comparison_op,
        comparison_sub_op: undefined,
        value: filter.value,
    };
    return handleDataTypes(result, aliasCol, throwErrorIfInvalid, errors);
}
function handleDataTypes(filterType, column, throwErrorIfInvalid = false, errors = []) {
    if (filterType.value === null) {
        return { filter: filterType };
    }
    if ([
        UITypes.Date,
        UITypes.DateTime,
        UITypes.CreatedTime,
        UITypes.LastModifiedTime,
    ].includes(column.uidt) &&
        filterType.value) {
        const [subOp, ...value] = Array.isArray(filterType.value)
            ? filterType.value
            : filterType.value.split(',').map((k) => k.trim());
        filterType.comparison_sub_op = subOp;
        filterType.value = value.join('');
        if (filterType.comparison_sub_op) {
            if (!COMPARISON_SUB_OPS.includes(filterType.comparison_sub_op)) {
                if (throwErrorIfInvalid)
                    throw new InvalidFilterError({
                        message: `Invalid filter '${filterType.comparison_sub_op}' is not supported`,
                    });
                else {
                    errors.push({
                        message: `Invalid filter '${filterType.comparison_sub_op}' is not supported`,
                    });
                    return { errors };
                }
            }
        }
        if ((filterType.comparison_op === 'isWithin' &&
            !IS_WITHIN_COMPARISON_SUB_OPS.includes(filterType.comparison_sub_op)) ||
            (filterType.comparison_op !== 'isWithin' &&
                IS_WITHIN_COMPARISON_SUB_OPS.includes(filterType.comparison_sub_op))) {
            if (throwErrorIfInvalid)
                throw new InvalidFilterError({
                    message: `Invalid filter '${filterType.comparison_sub_op}' is not supported for '${filterType.comparison_op}'`,
                });
            else {
                errors.push({
                    message: `Invalid filter '${filterType.comparison_sub_op}' is not supported for '${filterType.comparison_op}'`,
                });
                return { errors };
            }
        }
        if (filterType.value === '') {
            filterType.value = undefined;
        }
    }
    return { filter: filterType };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsdGVySGVscGVyc193aXRocGFyc2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi9maWx0ZXJIZWxwZXJzX3dpdGhwYXJzZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBS0EsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sOENBQThDLENBQUM7QUFDakYsT0FBTyxPQUFPLE1BQU0sV0FBVyxDQUFDO0FBQ2hDLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBQ2xFLE9BQU8sRUFDTCxrQkFBa0IsRUFFbEIsNEJBQTRCLEdBQzdCLE1BQU0saUJBQWlCLENBQUM7QUFDekIsT0FBTyxFQUNMLGNBQWMsRUFDZCxrQkFBa0IsRUFDbEIsc0JBQXNCLEVBQ3RCLDRCQUE0QixHQUM3QixNQUFNLDZDQUE2QyxDQUFDO0FBRXJELE1BQU0sVUFBVSx1QkFBdUIsQ0FDckMsR0FBc0IsRUFDdEIsY0FBcUQsRUFDckQsbUJBQW1CLEdBQUcsS0FBSyxFQUMzQixTQUE2QixFQUFFO0lBRS9CLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNULE9BQU8sRUFBRSxPQUFPLEVBQUUsRUFBRSxFQUFFLENBQUM7SUFDekIsQ0FBQztJQUNELEtBQUssTUFBTSxVQUFVLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDO1FBQ3JELE1BQU0sTUFBTSxHQUFHLGNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUMxQyxjQUFjLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQztJQUNyQyxDQUFDO0lBQ0QsT0FBTyw0QkFBNEIsQ0FDakMsR0FBRyxFQUNILGNBQWMsRUFDZCxtQkFBbUIsRUFDbkIsTUFBTSxDQUNQLENBQUM7QUFDSixDQUFDO0FBRUQsU0FBUyw0QkFBNEIsQ0FDbkMsR0FBc0IsRUFDdEIsY0FBcUQsRUFDckQsbUJBQW1CLEdBQUcsS0FBSyxFQUMz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