import dayjs from 'dayjs';
import { dateFormats } from '../../../lib/dateTimeHelper';
import { DATE_DIFF_TO_SCALE_LABEL_MAP, DATE_SCALE_LABEL_TO_DIFF_MAP, isNumberRound, parseDateValue, serializeDateOrDateTimeValue, } from '..';
import AbstractColumnHelper from '../column.interface';
import { SilentTypeConversionError } from '../../../lib/error';
import { parseProp } from '../../../lib/helperFunctions';
import { ncIsNullOrUndefined, ncIsUndefined } from '../../../lib/is';
import { populateFillHandleStrictCopy } from '../utils/fill-handler';
export class DateHelper extends AbstractColumnHelper {
    constructor() {
        super(...arguments);
        this.columnDefaultMeta = {
            date_format: dateFormats[0],
        };
    }
    serializeValue(value, params) {
        if (params.serializeSearchQuery)
            return null;
        value = serializeDateOrDateTimeValue(value, params.col);
        if (value === null) {
            if (params.isMultipleCellPaste) {
                return null;
            }
            else {
                throw new SilentTypeConversionError();
            }
        }
        return value;
    }
    parseValue(value, params) {
        return parseDateValue(value, params.col, params.isSystemCol);
    }
    parsePlainCellValue(value, params) {
        var _a;
        return (_a = parseDateValue(value, params.col, params.isSystemCol)) !== null && _a !== void 0 ? _a : '';
    }
    populateFillHandle(params) {
        var _a;
        const { column, highlightedData, numberOfRows } = params;
        if (highlightedData.length < 2) {
            return populateFillHandleStrictCopy(params);
        }
        // data is in form like 'YYYY-MM-DD' depends on meta dateformat
        const meta = parseProp(column.meta);
        const metaDateFormat = (_a = meta.date_format) !== null && _a !== void 0 ? _a : 'YYYY-MM-DD';
        const dateFormat = metaDateFormat + ' HH:mm:ss';
        let lastData;
        let modifier = undefined;
        let scale = 'D';
        const setModifierForScaleIfRound = (currentData, lastData, diffScale) => {
            const currentModifier = currentData.diff(lastData, diffScale, true);
            if (isNumberRound(currentModifier)) {
                scale = DATE_DIFF_TO_SCALE_LABEL_MAP[diffScale];
                modifier = currentModifier;
            }
        };
        // map to dayjs
        const dayJsHighlightedData = [];
        for (const date of highlightedData) {
            if (ncIsNullOrUndefined(date) ||
                date === '' ||
                typeof date !== 'string') {
                return populateFillHandleStrictCopy(params);
            }
            const currentData = dayjs(date + ' 00:00:00', dateFormat);
            // unlikely on normal case
            if (!currentData.isValid()) {
                return populateFillHandleStrictCopy(params);
            }
            if (!lastData) {
                lastData = currentData;
            }
            else {
                if (ncIsUndefined(modifier)) {
                    const modifierInDays = currentData.diff(lastData, 'day');
                    if (modifierInDays > 354) {
                        setModifierForScaleIfRound(currentData, lastData, 'year');
                    }
                    else if (modifierInDays > 28) {
                        setModifierForScaleIfRound(currentData, lastData, 'month');
                    }
                    else {
                        modifier = modifierInDays;
                        scale = 'D';
                    }
                }
                else {
                    const currentModifier = currentData.diff(lastData, DATE_SCALE_LABEL_TO_DIFF_MAP[scale]);
                    if (currentModifier !== modifier) {
                        return populateFillHandleStrictCopy(params);
                    }
                }
                lastData = currentData;
            }
            dayJsHighlightedData.push(lastData);
        }
        if (modifier === 0) {
            return populateFillHandleStrictCopy(params);
        }
        const numberToGenerate = numberOfRows - highlightedData.length;
        return Array.from({ length: numberToGenerate }).map(() => {
            const currentData = lastData.add(modifier, DATE_SCALE_LABEL_TO_DIFF_MAP[scale]);
            lastData = currentData;
            return currentData.format(metaDateFormat);
        });
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGF0ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY29sdW1uSGVscGVyL2NvbHVtbnMvRGF0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEtBQUssTUFBTSxPQUFPLENBQUM7QUFDMUIsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ25ELE9BQU8sRUFDTCw0QkFBNEIsRUFDNUIsNEJBQTRCLEVBQzVCLGFBQWEsRUFDYixjQUFjLEVBQ2QsNEJBQTRCLEdBQzdCLE1BQU0sSUFBSSxDQUFDO0FBQ1osT0FBTyxvQkFFTixNQUFNLHFCQUFxQixDQUFDO0FBQzdCLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUV4RCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDbEQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLGFBQWEsRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUM5RCxPQUFPLEVBQUUsNEJBQTRCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUVyRSxNQUFNLE9BQU8sVUFBVyxTQUFRLG9CQUFvQjtJQUFwRDs7UUFDRSxzQkFBaUIsR0FBRztZQUNsQixXQUFXLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQztTQUM1QixDQUFDO0lBOEhKLENBQUM7SUE1SEMsY0FBYyxDQUNaLEtBQVUsRUFDVixNQUEyQztRQUUzQyxJQUFJLE1BQU0sQ0FBQyxvQkFBb0I7WUFBRSxPQUFPLElBQUksQ0FBQztRQUM3QyxLQUFLLEdBQUcsNEJBQTRCLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUV4RCxJQUFJLEtBQUssS0FBSyxJQUFJLEVBQUUsQ0FBQztZQUNuQixJQUFJLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO2dCQUMvQixPQUFPLElBQUksQ0FBQztZQUNkLENBQUM7aUJBQU0sQ0FBQztnQkFDTixNQUFN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